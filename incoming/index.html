<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /></head><body><div class="calibre" id="calibre_link-7">
<div class="title">
Redécouvrir&nbsp;JavaScript avec&nbsp;Node.js<br class="calibre1"></br>
<br class="calibre1"></br>
<small class="calibre2">Sébastien Castiel</small>
</div>

</div>

<div class="calibre" id="calibre_link-4">
<h1 id="calibre_link-8" class="calibre3">Avant-propos</h1>
<p class="calibre4">JavaScript a toujours été l'un de mes langages préférés. Il
est souvent considéré comme un langage complexe à maintenir,
probablement à
cause des possibilités syntaxiques qu'il offre (<em class="calibre5">closures</em>,
notation JSON...), mais
en réalité il ne demande peut-être qu'un peu plus de rigueur que
d'autres
langages.</p>
<p class="calibre4">La première fois que j'ai entendu parler de Node.js et queg
j'ai vu quelques exemples de code, il m'a fallu quelques minutes pour
être
convaincu que tant de possibilités pouvaient être offertes en si peu de
lignes.
En écrivant ce livre, j'espère réussir à vous donner un aperçu de ses
possibilités, pour que vous preniez autant de plaisir à l'utiliser que
j'en ai
eu moi-même.</p>
<p class="calibre4">Ce livre vous exposera quelques possibilités offertes par
Node.js, en commençant naturellement par une rapide initiation aux
bases. Après
quelques rappels sur la syntaxe de JavaScript (chapitre&nbsp;1),
vous apprendrez&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7">comment installer Node.js sur votre ordinateur et écrire
votre premier programme
(chapitre&nbsp;2)&nbsp;;</li>
  <li class="calibre7">comment créer une petite application web bien
structurée à l'aide de templates
(chapitre&nbsp;3) ;</li>
  <li class="calibre7">comment utiliser des bases de données avec
Node.js (chapitre&nbsp;4)&nbsp;;</li>
  <li class="calibre7">comment créer vos propres modules et les
distribuer pour les rendre disponibles auprès de la communauté
(chapitre&nbsp;5).</li>
</ul>
<p class="calibre4">Je pars du principe que vous avez déjà utilisé JavaScript,
même si dans le premier chapitre je reviendrai sur les bases de la
syntaxe du
langage. Je suppose aussi que vous connaissez les rudiments des
échanges
réseaux d'une application web (appels AJAX, protocole HTTP...).</p>
<p class="calibre4">Notez également que les chapitres 3,
4 et 5
peuvent être lus dans n'importe quel ordre.</p>
<p class="calibre4">À présent j'espère que vous prendre plaisir à lire ce livre.
Pour tout critique, remarque ou suggestion, n'hésitez pas à me
contacter à
l'adresse&nbsp;: sebastien.castiel@gmail.com.</p>



</div>

<div class="calibre" id="calibre_link-2">
<h1 id="calibre_link-9" class="calibre3">Chapitre 1 :
JavaScript</h1>
<h2 id="calibre_link-10" class="calibre8">1.1&nbsp;&nbsp;&nbsp;&nbsp;
Historique</h2>
<p class="calibre4">JavaScript est un langage créé en 1995 pour le compte du
navigateur Netscape. Sa syntaxe a été ouvertement inspirée de Java. Les
deux
langages étaient d'ailleurs présentés en complément (les sociétés
Netscape et
Sun Microsystems étant partenaires), ce qui a créé une confusion
générale,
encore présente aujourd'hui. Disons-le clairement&nbsp;: JavaScript
et Java ne
sont pas (ou plus) du tout liés. (On entend souvent l'analogie "Java is
to JavaScript as ham is to hamster", ou Java est à JavaScript ce que le
jambon (ham) est au hamster.)</p>
<p class="calibre4">Depuis, JavaScript a été standardisé par l'organisme <em class="calibre5">ECMA
International</em> (le standard a été nommé<em class="calibre5">ECMAScript</em>).
C'est un langage qui évolue encore, les versions 1.7 et 1.8, apportant
plusieurs nouvelles possibilités, sont progressivement supportées par
les
navigateurs (et par Node.js&nbsp;!).</p>
<p class="calibre4">JavaScript a connu plusieurs essors. Tout d'abord, il a
ajouté aux pages HTML statiques des effets pour les rendre plus
dynamiques&nbsp;: des animations au survol d'une image, des textes
defilants, etc. Aujourd'hui ces effets (qui avaient été
globalement nommés <em class="calibre5">DHTML</em> pour <em class="calibre5">Dynamic</em>
<em class="calibre5">
HTML</em>) nous semblent un peu vieillots, caractéristiques du
web des années
1990-début 2000.</p>
<p class="calibre4">Vers le début des années 2000, JavaScript connaît alors un
deuxième essor majeur, avec l'apparition d'une technologie qui
révolutionnera
la manière dont on utilise Internet&nbsp;: Ajax <em class="calibre5">(Asynchronous
JavaScript and XML)</em>.
Pour faire simple, Ajax consiste à
utiliser des possibilités de JavaScript et des navigateurs pourtant
présentes
depuis fort longtemps pour faire charger des données depuis le serveur
sans
avoir besoin de recharger la page. Cela paraît simple, pourtant cette
avancéea permis de concevoir des applications web tellement
réactives qu'elles se sont progressivement substituées
aux applications de bureau.</p>
<p class="calibre4">Pour faciliter l'utilisation d'Ajax (et notamment pour gérer
les différences d'implémentation entre les navigateurs), plusieurs
bibliothèques JavaScript ont vu le jour&nbsp;; celle qui fait
référence
aujourd'hui est <em class="calibre5">jQuery</em> (http://jquery.com).</p>
<p class="calibre4">Enfin, on assiste aujourd'hui à une nouvelle avancée majeure
de l'utilisation de JavaScript. Alors que jQuery
permet de faire des appels Ajax et de manipuler une page HTML très
facilement,
certains frameworks vont encore plus loin en créant des applications
JavaScript
complexes et structurées, par exemple en donnant la possibilité
d'utiliser une
architecture <em class="calibre5">modèle-vue-controleur (MVC)</em>, avec
gestion de modèles <em class="calibre5">(templates)</em>. Et pour
accompagner cette tendance, cela
se passe à la fois&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7">côté client&nbsp;: avec des frameworks comme Backbone
ouAngularJS&nbsp;;</li>
  <li class="calibre7">côté serveur&nbsp;: avec Node.js, c'est l'objet
de ce livre&nbsp;!</li>
</ul>
<p class="calibre4">Il est donc désormais possible d'utiliser avec JavaScript
des méthodes réservées il y a peu aux gros langages comme PHP, Java ou
Ruby&nbsp;:
architecture MVC, tests unitaires,<em class="calibre5">build</em>,
distribution de modules, gestion de dépendances, etc.</p>
<h2 id="calibre_link-11" class="calibre8">1.2&nbsp;&nbsp;&nbsp;&nbsp;
Les
bases du langage</h2>
<p class="calibre4">Bien que ce livre suppose que vous soyez déjà familier avec
JavaScript, il peut être utile de rappeler quelques bases du langage
que même
les plus expérimentés d'entre nous pourraient avoir oublié. Si vous
êtes
confiant, rien ne vous empêche de passer au chapitre suivant&nbsp;!</p>
<h3 id="calibre_link-12" class="calibre9">1.2.1&nbsp;&nbsp;&nbsp;
Les variables</h3>
<p class="calibre4">Une variable se déclare en JavaScript avec l'instruction <em class="calibre5">var</em>.
On lui affecte une valeur grâce à l'opérateur = (égal) et les
opérateurs arithmétiques
bien connus&nbsp;: <span class="code">+, -, *, /</span>, etc.</p>
<div class="code1">
var a;<br class="calibre1"></br>
var b = 1;<br class="calibre1"></br>
a = b + 2;
</div>
<h3 id="calibre_link-13" class="calibre9">1.2.2&nbsp;&nbsp;&nbsp;
Les types simples</h3>
<p class="calibre4">Les types de données élémentaires sont également les mêmes
que dans les langages les plus courants&nbsp;:</p>
<div class="code1">
a =
true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// booléen<br class="calibre1"></br>
a =
1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// entier<br class="calibre1"></br>
a =
1.1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
flottant<br class="calibre1"></br>
a = "Hello";&nbsp;&nbsp;&nbsp; // chaîne de
caractères<br class="calibre1"></br>
a = 'Hello';&nbsp;&nbsp;&nbsp; // idem
</div>
<h3 id="calibre_link-14" class="calibre9">1.2.3&nbsp;&nbsp;&nbsp;
Les
tableaux et les objets</h3>
<p class="calibre4">Parmi les types de données plus complexes, on retrouve
d'abord les tableaux, qui peuvent être initialisés grâce à la notation
JSON
avec des crochets&nbsp;:</p>
<div class="code1">
var t = [ 1,
true, 'Hello' ];<br class="calibre1"></br>
var u = t[0]; // u = 1
</div>
<p class="calibre4">JSON <em class="calibre5">(JavaScript Object Notation)</em> est un
langage permettant de représenter des données, notamment en JavaScript,
bien qu'il puisse être utilisé avec quasimment tous les langages. Plus
d'informations sur http://www.json.org/json-fr.html.
</p>
<p class="calibre4">On trouve également les tableaux associatifs, ou
dictionnaires,
qui en JavaScript sont appelés <em class="calibre5">objets</em>, et sont
initialisés grâce à une
notation avec des accolades&nbsp;:</p>
<div class="code1">
var o = {
prop1: 'Hello', prop2: 'World!' };<br class="calibre1"></br>
var v = o['prop1']; // les deux lignes sont<br class="calibre1"></br>
var v = o.prop1;&nbsp;&nbsp;&nbsp; // équivalentes
</div>
<h3 id="calibre_link-15" class="calibre9">1.2.4&nbsp;&nbsp;&nbsp;
Les fonctions</h3>
<p class="calibre4">En JavaScript les fonctions ne sont rien d'autres qu'un type
de donnée. Une «&nbsp;fonction&nbsp;» comme on l'entend dans
les autres langages est donc
en JavaScript une variable contenant une donnée de type
fonction&nbsp;:</p>
<div class="code1">
var f =
function(i) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; return i + 1;<br class="calibre1"></br>
};
</div>
<p class="calibre4">Il est possible d'utiliser une notation plus conventionnelle
:</p>
<div class="code1">
function f() {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; return i + 1;<br class="calibre1"></br>
}
</div>
<p class="calibre4">Un objet ou un tableau peut donc contenir une
fonction&nbsp;:</p>
<div class="code1">
var o = {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; f: function(i)
{<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return i + 1;<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; }<br class="calibre1"></br>
};<br class="calibre1"></br>
var a =o.f(1); // a = 2
</div>
<h3 id="calibre_link-16" class="calibre9">1.2.5&nbsp;&nbsp;&nbsp;
Mixons le tout</h3>
<p class="calibre4">Avec tous ces types de données, on peut créer des objets
plutôt complexes&nbsp;:</p>
<div class="code1">
var o = {<br class="calibre1"></br>
&nbsp; t: 1,<br class="calibre1"></br>
&nbsp; s: [<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; 'test',<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;function(p)
{<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return function(q,
f, t) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
u = q +
(f(t))(q);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return {
somme: q + p, produit: q * p };<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; }<br class="calibre1"></br>
&nbsp; ]<br class="calibre1"></br>
};
</div>

</div>

<div class="calibre" id="calibre_link-5">
<h1 id="calibre_link-17" class="calibre3">Chapitre
2 :
Découverte
de Node.js</h1>
<h2 id="calibre_link-18" class="calibre8">2.1&nbsp;&nbsp;&nbsp;&nbsp;
Présentation</h2>
<p class="calibre4">Depuis sa création, JavaScript a naturellement été associé
aux sites et applications web, domaine pour lequel il a été créé. Il a
permis
de rendre les pages web plus dynamiques, en commençant par des
animations très <em class="calibre5">flashy</em>
dans les années 1990/2000 (ce que l'on appelait le DHTML), pour en
arriver vers
les applications les plus complexes que nous connaissons tous
aujourd'hui et
qui se substituent aux applications de bureau&nbsp;: webmail avec
Gmail,
cartographie avec Google Maps, etc.</p>
<p class="calibre4">Mais si JavaScript a été créé plus spécialement pour être
exécuté dans un navigateur, il a été standardisé et permet
théoriquement d'être
utilisé pour tout type d'application, et notamment des programmes
autonomes,
c'est-à-dire ne nécessitant pas de navigateur web pour s'exécuter.
C'est sur
cet usage que se base Node.js.</p>
<p class="calibre4">Node.js se constitue d'un programme (appelé <em class="calibre5">node</em>)
permettant d'interpréter du code JavaScript, traditionnellement en
ligne de
commande. Il est également accompagné d'outils supplémentaires, dont le
plus
intéressant s'appelle <em class="calibre5">npm</em>, pour <em class="calibre5">Node
package manager</em>. Il s'agit d'un gestionnaire de paquet à
l'image de <em class="calibre5">yum</em> ou <em class="calibre5">apt</em> (pour
les distributions Linux RedHat et Debian/Ubuntu respectivement), sauf
que lui
permet de récupérer proprement des outils tiers utilisables avec
Node.js.</p>
<p class="calibre4">Note&nbsp;: dans la suite du livre, pour faire référence à
Node.js, je pourrais également parler simplement de <em class="calibre5">Node</em>.</p>
<h2 id="calibre_link-19" class="calibre8">2.2&nbsp;&nbsp;&nbsp;&nbsp;
Installation</h2>
<p class="calibre4">Node est un outil multiplateforme. Il est possible très
facilement de l'utiliser sous Linux, Windows, OS X, etc. Son
installation de
Node.js est on ne peut plus simple&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7">sous Windows, rendez-vous sur le site officiel
de Node (http://nodejs.org)
qui à ce jour propose en page d'accueil un lien permettant de
télécharger
l'installeur&nbsp;;</li>
  <li class="calibre7">sous Linux ou MacOS, votre gestionnaire de
paquets favori permet généralement de trouver le programme <em class="calibre5">node</em>
ou <em class="calibre5">nodejs</em>
sans problème.</li>
</ul>
<p class="calibre4">Pour vérifier que l'installation a bien été effectuée,
lancez en ligne de commande la commande suivante&nbsp;:</p>
<div class="code1">
node --version
</div>
<p class="calibre4">Le résultat doit être la version de Node.js installée
(v0.10.18 au moment de l'écriture de ce livre).</p>
<p class="calibre4">À présent que tout est en place, passons à l'écriture de
notre premier script Node.js&nbsp;!</p>
<h2 id="calibre_link-20" class="calibre8">2.3&nbsp;&nbsp;&nbsp;&nbsp;
Hello World!</h2>
<p class="calibre4">Pour notre premier script, nous allons créer un petit
serveur web. Là vous devez vous dire que c'est ambitieux comme premier
exercice, mais c'est parce que vous ne connaissez pas encore
Node.js&nbsp;!</p>
<h3 id="calibre_link-21" class="calibre9">2.3.1&nbsp;&nbsp;&nbsp;
Le code du programme</h3>
<p class="calibre4">J'ai volontairement choisi de reprendre le programme
d'exemple disponible en page d'accueil du site officiel de Node, car
celui-ci montre de manière très
efficace l'une des principales qualités de Node&nbsp;: sa concision.</p>
<p class="calibre4">Voici le code du programme&nbsp;:</p>
<div class="code1">
var http = require('http');<br class="calibre1"></br>
http.createServer(function (req, res) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.writeHead(200,
{'Content-Type': 'text/plain'});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.end('Hello
World\n');<br class="calibre1"></br>
}).listen(1337, '127.0.0.1');<br class="calibre1"></br>
console.log('Server running at
http://127.0.0.1:1337/');
</div>
<p class="calibre4">Et c'est tout&nbsp;! Avant d'expliquer le contenu du
script,
je vous propose de l'exécuter pour découvrir la magie. Pour cela créez
un
fichier appelé par exemple <em class="calibre5">hello.js</em> dans lequel
vous placez le code
ci-dessus. Puis ouvrez la ligne de commande, placez-vous dans le
répertoire du
script, et tapez la commande <span class="code">node hello.js</span>&nbsp;;
l'affichage devrait être le
suivant&nbsp;:</p>
<div class="code1">
$ node hello.js<br class="calibre1"></br>
Server running at http://127.0.0.1:1337/
</div>
<p class="calibre4">Le programme est en attente, c'est normal c'est notre
serveur qui tourne. À présent ouvrez votre navigateur web et
rendez-vous à
l'URL <em class="calibre5">http://127.0.0.1:1337</em>&nbsp;; le texte
«&nbsp;Hello World&nbsp;»
s'affiche.</p>
<p class="calibre4">Donc si on résume, vous venez de créer un serveur web en 6
lignes de code&nbsp;! (Et encore, l'une d'elles ne sert qu'à
afficher un
message «&nbsp;Server running…&nbsp;»)</p>
<h3 id="calibre_link-22" class="calibre9">2.3.2&nbsp;&nbsp;&nbsp;
Explication détaillée</h3>
<p class="calibre4">Passons à l'explication de ce programme, ligne par ligne (ou
presque).</p>
<div class="code1">
var http = require('http');
</div>
<p class="calibre4">Comme je l'ai dit, Node.js permet d'utiliser des outils
tiers appelés modules. Il inclut de nombreux modules de base, parmi eux
le
module <em class="calibre5">http</em> permettant de créer un serveur web.
Par la fonction require,
nous demandons à Node.js d'inclure le module <em class="calibre5">http</em>,
et nous décidons
d'accéder à ses méthodes via un objet http. (Nous aurions pu écrire <span class="code">var
toto = require('http');
toto.createServer(…)</span> mais cela aurait
été moins parlant…)</p>
<div class="code1">
http.createServer(function(req,res)
{ ... }).listen(1337, '127.0.0.1');
</div>
<p class="calibre4">La méthode createServer de l'objet http permet
comme son nom l'indique de créer un serveur, en l'occurrence un serveur
web
(HTTP). Nous reviendrons sur la fonction qu'elle prend en paramètres
dans
quelques instants.</p>
<p class="calibre4">Elle renvoie un objet «&nbsp;serveur&nbsp;», qui est
ici masqué en
appelant directement se méthode <span class="code">listen</span>. On
aurait pu
écrire&nbsp;:</p>
<div class="code1">
var server = http.createServer(function(req,res)
{ ... });<br class="calibre1"></br>
server.listen(1337, '127.0.0.1');
</div>
<p class="calibre4">La méthode listen du serveur permet de
lancer l'écoute, ici sur le port 1337 de l'hôte 127.0.0.1 <em class="calibre5">(localhost)</em>.
Autrement dit, c'est grâce à cette méthode
qu'on lance notre serveur.</p>
<div class="code1">
function (req, res) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.writeHead(200,
{'Content-Type': 'text/plain'});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.end('Hello
World\n');<br class="calibre1"></br>
}
</div>
<p class="calibre4">La fonction qui est passée en paramètre à <em class="calibre5">createServer</em>
est celle qui sera appelée à chaque
requête sur notre serveur. Elle prend elle-même deux
paramètres&nbsp;: la
requête (<span class="code">req</span>) et la réponse (<span class="code">res</span>).
(Nous aurions pu appeler les paramètres autrement évidemment, le
principal
étant qu'ils soient là, et qu'ils soient deux.)</p>
<ul class="calibre6">
  <li class="calibre7">La <em class="calibre5">requête</em> est un objet permettant
d'accéder
aux détails sur la requête envoyée au serveur&nbsp;: en-têtes HTTP,
paramètres
GET ou POST, etc. Nous ne l'utilisons pas ici.</li>
  <li class="calibre7">La <em class="calibre5">réponse</em> est l'objet qui nous
permet
d'envoyer une réponse à la requête. Dans notre cas, nous effectuons
deux
actions sur cette réponse&nbsp;:
<ul class="calibre10">
    <li class="calibre7">Nous
définissons l'en-tête HTTP <em class="calibre5">Content-type</em> à <em class="calibre5">text</em><em class="calibre5">/plain</em>,
ce qui permet d'indiquer que le contenu que nous renvoyons est de type
texte.
Il pourrait être <em class="calibre5">text</em><em class="calibre5">/html</em>, <em class="calibre5">application/json</em>,
bref ce que l'on veut tant qu'il s'agit d'un type
MIME standard&nbsp;;</li>
    <li class="calibre7">Nous
terminons la requête en envoyant le texte <em class="calibre5">Hello World</em>
(suivi d'un retour
à la ligne, qui n'est pas indispensable ici).</li>
  </ul></li>
</ul>
<p class="calibre4">Note&nbsp;sur les fonctions callbacks&nbsp;: il est
très
fréquent de voir avec Node.js des fonctions qui prennent d'autres
fonctions en
paramètres. Le principe est généralement de passer en paramètre à une
fonction,
une seconde fonction à exécuter lorsque la première est terminée. Cette
seconde
fonction est généralement désignée par le terme de <em class="calibre5">callback</em>.
Par exemple
:</p>
<div class="code1">
var f1 =function(callback) {<br class="calibre1"></br>
&nbsp; console.log("Première fonction...");<br class="calibre1"></br>
&nbsp; callback("test");<br class="calibre1"></br>
};<br class="calibre1"></br>
var f2 =function(resultat)
{<br class="calibre1"></br>
&nbsp; console.log("Résultat&nbsp;: " +resultat);<br class="calibre1"></br>
}<br class="calibre1"></br>
f1(f2);<br class="calibre1"></br>
<br class="calibre1"></br>
// Sortie&nbsp;:<br class="calibre1"></br>
//&nbsp;&nbsp; Première fonction...<br class="calibre1"></br>
//&nbsp;&nbsp; Résultat&nbsp;: test
</div>
<p class="calibre4">Dans la dernière ligne, la fonction <em class="calibre5">console.log</em>
permet d'afficher un message dans la console (la sortie de la ligne de
commande), ce qui nous sert ici à indiquer que le serveur a bien
démarré&nbsp;:</p>
<div class="code1">
console.log('Server
running at http://127.0.0.1:1337/');
</div>
<h3 id="calibre_link-23" class="calibre9">2.3.3&nbsp;&nbsp;&nbsp;
En résumé</h3>
<p class="calibre4">Pour créer notre serveur web, nous avons&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7">inclut le module <em class="calibre5">http</em> avec la
fonction <span class="code">require</span>;</li>
  <li class="calibre7">créé un serveur HTTP avec la méthode <span class="code">createServer</span>,
en lui fournissant une fonction plaçant le texte <em class="calibre5">Hello World</em>
dans la
réponse renvoyée à chaque requête&nbsp;;</li>
  <li class="calibre7">mis le serveur en écoute sur le port 1337&nbsp;;</li>
  <li class="calibre7">indiqué dans la console que le serveur était
lancé.</li>
</ul>
<p class="calibre4">Magique non&nbsp;? Pour terminer ce chapitre consacré aux
bases de Node.js, étudions un exemple légèrement plus complexe…</p>
<h2 id="calibre_link-24" class="calibre8">2.4&nbsp;&nbsp;&nbsp;&nbsp;
Un
exemple plus complexe...</h2>
<p class="calibre4">Dans cette partie nous allons raffiner le petit serveur web
créé précédemment en ajoutant quelques fonctionnalités. Nous allons
imaginer
une application très simple, demandant à l'utilisateur son prénom, pour
le
saluer personnellement ensuite. Il ne s'agit pas ici de vendre ce
concept
révolutionnaire aux grands noms du web, mais d'illustrer plusieurs
fonctionnalités offertes par Node.js&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7">Récupérer et utiliser les paramètres GET passés
à la requête&nbsp;;</li>
  <li class="calibre7">Lire un fichier HTML local et le renvoyer au
navigateur&nbsp;;</li>
  <li class="calibre7">Renvoyer du contenu structuré en JSON.</li>
</ul>
<p class="calibre4">Notre application se constituera d'un formulaire contenant
un champ invitant l'utilisateur à saisir son nom. Un clic sur le bouton
OK
lancera un appel AJAX, qui recevra en réponse un message adapté au nom
de
l'utilisateur. Le message sera affiché sur la page.</p>
<h3 id="calibre_link-25" class="calibre9">2.4.1&nbsp;&nbsp;&nbsp;
Une page HTML</h3>
<p class="calibre4">Tout d'abord, nous aurons besoin d'un fichier HTML classique
contenant un formulaire, permettant à l'utilisateur de saisir son
nom&nbsp;:
(appelons le <em class="calibre5">hello02.html</em>, nous l'utiliserons
ensuite).</p>
<div class="code1">
&lt;input type="text" placeholder="Enter your name"
id="name"/&gt;<br class="calibre1"></br>
&lt;input type="button" value="OK"
onclick="valid()"/&gt;<br class="calibre1"></br>
&lt;div id="message"&gt;&lt;/div&gt;<br class="calibre1"></br>
&lt;scriptsrc="http://code.jquery.com/jquery-1.10.1.min.js"&gt;&lt;/script&gt;<br class="calibre1"></br>
&lt;script&gt;<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; function valid() {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$.get('', {
name: $('#name').val() }, function(data) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$('#message').html(data.message);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}, 'json');<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; }<br class="calibre1"></br>
&lt;/script&gt;
</div>
<p class="calibre4">Passons sur la validité HTML de ce code, seul le nécessaire
s'y trouve. Tout d'abord un champ texte name,
puis un bouton <em class="calibre5">OK</em> qui lorsque l'on clique dessus
appelle la fonction <span class="code">valid()</span> définie
ensuite. On utilisejQuery pour réaliser un appel
AJAX. Le script passé en premier paramètre à <span class="code">$.get</span>
est
vide, ce qui indique au navigateur d'appeler la page sur laquelle on se
trouve.</p>
<p class="calibre4">Si vous ouvrez la page dans votre navigateur et que vous
remplissez le champ et cliquez sur le bouton, vous pourrez à l'aide
d'un outil
comme Firebug ou les outils de développement Chrome visualiser la
requête qui
est envoyée via Ajax&nbsp;: <em class="calibre5">file:///.../hello02.html?name=Paul</em>.</p>
<p class="calibre4">Pas de Node.js ici, mais ne vous inquiétez pas, ça
arrive&nbsp;!</p>
<h3 id="calibre_link-26" class="calibre9">2.4.2&nbsp;&nbsp;&nbsp;
Le script Node.js</h3>
<p class="calibre4">Le script Node de notre application a deux utilités&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7">afficher notre fichier HTML lorsqu'aucun
paramètre ne lui est passé&nbsp;;</li>
  <li class="calibre7">répondre à l'appel AJAX par une réponse JSON.</li>
</ul>
<p class="calibre4">Voici le code source du script&nbsp;:</p>
<div class="code1">
var http = require('http');<br class="calibre1"></br>
var url = require('url');<br class="calibre1"></br>
varfs = require('fs');<br class="calibre1"></br>
<br class="calibre1"></br>
var server = http.createServer(function (req, res) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; var url_parts
= url.parse(req.url, true);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; var name
= url_parts.query.name;<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; if (name)
{<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console.log('Name: ' +name);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res.writeHead(200, {'Content-Type': 'application/json'});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res.end(JSON.stringify({message:
'Hello ' +name + '!'}));<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; } else {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console.log('Noname!');<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res.writeHead(200, {'Content-Type': 'text/html'});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fs.readFile('hello02.html',function
(err,data) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res.end(data);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; }<br class="calibre1"></br>
}).listen(1337,
'127.0.0.1');<br class="calibre1"></br>
<br class="calibre1"></br>
console.log('Server running at
http://127.0.0.1:1337/');
</div>
<p class="calibre4">De la même manière que pour l'exemple précédent, analysons
en détail le contenu de ce script.</p>
<div class="code1">
var http =
require('http');<br class="calibre1"></br>
varurl = require('url');<br class="calibre1"></br>
varfs = require('fs');
</div>
<p class="calibre4">Nous avions déjà vu le module <em class="calibre5">http</em>, nous
utilisons
ici en plus les modules <em class="calibre5">url</em> et <em class="calibre5">fs</em>
(également inclus avec Node), permettant respectivement d'analyser une
URL avec
ses paramètres, et de lire un fichier sur le serveur local. Nous allons
voir un
peu plus bas l'utilisation de ces deux modules.</p>
<div class="code1">
var url_parts =url.parse(req.url,
true);<br class="calibre1"></br>
var name = url_parts.query.name;<br class="calibre1"></br>
if (name) {<br class="calibre1"></br>
&nbsp; &nbsp;&nbsp;...<br class="calibre1"></br>
} else {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; ...<br class="calibre1"></br>
}
</div>
<p class="calibre4">La première chose que nous faisons dans la fonction donnée à <span class="code">createServer</span>
est de récupérer l'URL appelée, et de la décomposer grâce à la méthode <span class="code">parse</span>
du module <em class="calibre5">url</em>.
Nous récupérons un objet dont la propriété <span class="code">query</span>
contient ici les paramètres GET. Celui qui nous intéresse est ici le
paramètre <span class="code">name</span>.</p>
<p class="calibre4">Autrement dit, si dans notre navigateur nous appelons l'URL <em class="calibre5">http://127.0.0.1:1337/?name=Jacques</em>,
notre variable name contiendra
la chaîne «&nbsp;Jacques&nbsp;».</p>
<p class="calibre4">En fonction de la présence ou non de ce paramètre, nous
allons adopter deux comportements différents.</p>
<div class="code1">
console.log('No
name!');<br class="calibre1"></br>
res.writeHead(200, {'Content-Type': 'text/html'});<br class="calibre1"></br>
fs.readFile('hello02.html', function (err,data)
{<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.end(data);<br class="calibre1"></br>
});
</div>
<p class="calibre4">Dans le cas où aucun nom n'est fourni (on appelle l'URL sans
paramètre), on commence par afficher le message «&nbsp;No
name!&nbsp;»
dans la console. Puis on définit le contenu de la réponse HTTP comme de
type
«&nbsp;text/html&nbsp;», c'est à dire une page HTML
classique.</p>
<p class="calibre4">Puis on fait appel à la méthode <span class="code">readFile</span>
du module <em class="calibre5">fs</em> qui nous permet de lire un
fichier local, ici <em class="calibre5">hello02.html</em>, le fichier que
nous avons créé
précédemment et contenant le formulaire. On peut voir que le deuxième
paramètre
de cette méthode est une fonction, appelée lorsque le fichier a été lu.
Son
contenu y est passé dans le paramètre data.</p>
<p class="calibre4">Dit simplement&nbsp;: s'il n'y a pas de nom fourni, on
renvoie le contenu du fichier <em class="calibre5">hello02.html</em>.</p>
<div class="code1">
console.log('Name: ' +
name);<br class="calibre1"></br>
res.writeHead(200, {'Content-Type': 'application/json'});<br class="calibre1"></br>
res.end(JSON.stringify({message: 'Hello '
+ name + '!'}));
</div>
<p class="calibre4">Dans le cas où un nom est fourni, on ne renvoie plus le
formulaire HTML, mais une réponse structurée, codée en JSON. On définit
donc le
<em class="calibre5">Content-type</em> à <em class="calibre5">application/json</em>,
puis
on renvoie notre objet <span class="code">{ message: 'Hello Jean' }</span>
que l'on code en JSON via la méthode <span class="code">JSON.stringify</span>
(fournie par Node.js).</p>
<h3 id="calibre_link-27" class="calibre9">2.4.3&nbsp;&nbsp;&nbsp;
En résumé</h3>
<p class="calibre4">Dans ce deuxième exemple, nous avons vu&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7">comment utiliser le module <em class="calibre5">url</em> pour
analyser
une URL et récupérer un paramètre GET&nbsp;;</li>
  <li class="calibre7">comment lire un fichier HTML et le renvoyer en
réponse afin d'afficher notre formulaire&nbsp;;</li>
  <li class="calibre7">comment renvoyer une réponse structurée (en
JSON) afin que celle-ci soit analysée lors d'un appel AJAX.</li>
</ul>
<p class="calibre4">J'espère vous avoir convaincu avec ces deux exemples de la
simplicité et de la concision de Node.js. Dans la suite du livre je
vous
présenterai des fonctionnalités plus avancées offertes par Node.js. Et
dans le
chapitre suivant, nous verrons comment créer un site ou une application
web en
structurant un peu mieux notre code.</p>

</div>

<div class="calibre" id="calibre_link-0">
<h1 id="calibre_link-28" class="calibre3">Chapitre
3 :
Un site
web bien architecturé avec Express</h1>
<p class="calibre4">Lorsque l'on crée un site ou une application web, il est
nécessaire que celui/celle-ci soit bien architecturé(e). C'est
justement le but
d'un framework. À l'instar des «&nbsp;gros&nbsp;» frameworks
comme Symfony et Ruby On
Rails, Express permet d'organiser votre application web en fonction des
requêtes qu'elle est censée recevoir. Vous l'aurez compris,
contrairement aux
autres frameworks cités précédemment, Express reste dans la philosophie
de
Node.js en étant léger et très simple à mettre en œuvre.</p>
<h2 id="calibre_link-29" class="calibre8">3.1&nbsp;&nbsp;&nbsp;&nbsp;
Installation
de Express</h2>
<p class="calibre4">Contrairement à <em class="calibre5">http</em> ou <em class="calibre5">url</em>
que nous avons
utilisés précédemment, Express (qui se constitue principalement du
module <em class="calibre5">express</em>)
ne fait pas partie de la distribution de base de Node.js. Pour
l'inclure à
notre application, il suffit de suivre la procédure suivante&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7">Se rendre en ligne de commande dans le
répertoire de notre application (répertoire vierge ou répertoire
utilisé pour
les exemples précédents)&nbsp;;</li>
  <li class="calibre7">Utiliser le gestionnaire de paquets de Node.js <em class="calibre5">npm</em>
grâce à la commande&nbsp;: <span class="code">npminstall
express</span></li>
</ul>
<p class="calibre4">La commande va télécharger le module <em class="calibre5">express</em>
ainsi
que tous les modules dont il dépend (et ils sont nombreux). Si tout se
passe
bien, vous devez remarquer l'apparition d'un répertoire <em class="calibre5">node_modules</em>
dans votre répertoire courant.</p>
<p class="calibre4">Note sur les modules&nbsp;: vous le comprendrez
rapidement&nbsp;: la philosophie des modules de Node est un module
= une
utilité. Autrement dit, un module n'accomplit en général qu'une tâche
précise.
C'est l'utilisation conjointe de plusieurs modules qui permet de
générer des
applications (ou modules) plus complexes.</p>
<h2 id="calibre_link-30" class="calibre8">3.2&nbsp;&nbsp;&nbsp;&nbsp;
Une
application basique avec Express</h2>
<p class="calibre4">Afin d'en découvrir le fonctionnement de base, je vous
propose de reprendre notre application révolutionnaire du chapitre
précédent,
celle qui demande son nom à l'utilisateur pour le saluer ensuite.</p>
<p class="calibre4">Voici pour rappel le code principal de l'application telle
que nous l'avons écrit&nbsp;:</p>
<div class="code1">
var url_parts
= url.parse(req.url, true);<br class="calibre1"></br>
var name =
url_parts.query.name;<br class="calibre1"></br>
if (name) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.writeHead(200,
{'Content-Type': 'application/json'});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.end(JSON.stringify({message: 'Hello '
+name
+ '!'}));<br class="calibre1"></br>
} else {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.writeHead(200,
{'Content-Type': 'text/html'});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;fs.readFile('hello02.html',
function (err,data) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res.end(data);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; });<br class="calibre1"></br>
}
</div>
<p class="calibre4">On voit que les différents cas de figure qui peuvent se
présenter sont distingués par un <em class="calibre5">if</em>. Ici nous
n'en avons que deux, mais
si nous devions traiter dix types de requêtes différents, le programme
deviendrait vite illisible… C'est alors que l'usage d'un <em class="calibre5">routeur</em>
va nous
simplifier la vie.</p>
<p class="calibre4">Plongeons aucoeur du sujet, voici
le code de la version de notre programme utilisant Express&nbsp;:</p>
<div class="code1">
var express =require('express');<br class="calibre1"></br>
varfs = require('fs');<br class="calibre1"></br>
<br class="calibre1"></br>
varapp = express();<br class="calibre1"></br>
<br class="calibre1"></br>
app.get('/',function(req,
res){<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.writeHead(200,
{'Content-Type': 'text/html'});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;fs.readFile('express01.html',
function (err,data) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res.end(data);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; });<br class="calibre1"></br>
});<br class="calibre1"></br>
<br class="calibre1"></br>
app.get('/hello/:name', function(req,res){<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.writeHead(200,
{'Content-Type': 'application/json'});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.end(JSON.stringify({message: 'Hello '
+ req.params.name +
'!'}));<br class="calibre1"></br>
});<br class="calibre1"></br>
<br class="calibre1"></br>
app.listen(8080);
</div>
<p class="calibre4">À première vue, et même sans connaître le fonctionnement
d'Express, le code semble déjà plus «&nbsp;aéré&nbsp;».</p>
<div class="code1">
var express =
require('express');<br class="calibre1"></br>
varfs = require('fs');<br class="calibre1"></br>
<br class="calibre1"></br>
var app = express();
</div>
<p class="calibre4">On inclut comme d'habitude les modules que l'on va utiliser.
Nous avons déjà vu le module <em class="calibre5">fs</em> permettant de
lire un fichier&nbsp;; le module <em class="calibre5">express</em>
s'inclut de la même manière
pour créer la fonction <span class="code">express()</span> qui sert à
créer notre application <span class="code">app</span>.
Cette application est l'objet global que nous utiliserons pour
configurer les
actions à effectuer en fonction de la requête.</p>
<div class="code1">
app.get('/',function(req,
res){<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.writeHead(200,
{'Content-Type': 'text/html'});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;fs.readFile('express01.html',
function (err,data) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res.end(data);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; });<br class="calibre1"></br>
});
</div>
<p class="calibre4">La méthode <span class="code">get</span> de l'objet <span class="code">app</span>
nous permet ici de définir le comportement lorsque c'est l'URL <em class="calibre5">http://localhost:8080/</em>
qui est appelée, autrement dit la racine (<span class="code">/</span>)
de notre site. Le contenu de la
fonction qu'elle prend en deuxième paramètre est strictement identique
à celui
vu au chapitre précédent&nbsp;: on lit le fichier <em class="calibre5">express01.html</em>
et on
le renvoie.</p>
<div class="code1">
app.get('/hello/:name', function(req,res){<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.writeHead(200,
{'Content-Type': 'application/json'});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.end(JSON.stringify({message: 'Hello '
+ req.params.name +
'!'}));<br class="calibre1"></br>
});
</div>
<p class="calibre4">Le deuxième cas de figure est plus intéressant. On gère ici le
cas où l'URL est de la forme <span class="code">/hello/:name</span>. La
partie <span class="code">:name</span> correspond ici à un paramètre,
c'est à dire à une valeur qui pourra être remplacée par n'importe quoi.
Par
exemple, si l'on appelle l'URL <em class="calibre5">http://localhost:8080/hello/Jean</em>,
c'est cette fonction qui sera utilisée.</p>
<p class="calibre4">Le plus intéressant avec ce paramètre est évidemment qu'il
est possible de récupérer sa valeur. C'est ce qui est fait lorsque l'on
renvoie
le contenu en JSON, via <span class="code">req.params.name</span>.
C'est tout de même beaucoup plus simple que de récupérer l'URL, de la
décomposer avec le module <em class="calibre5">url</em>, et d'adapter le
comportement en fonction
de la présence ou non du paramètre name&nbsp;!</p>
<p class="calibre4">Bien évidemment, les fonctionnalités proposées par Express
vont bien au-delà de cela, continuons notre exploration avec une
fonction dont
tout webmaster un minimum rigoureux a besoin&nbsp;: les templates.</p>
<h2 id="calibre_link-31" class="calibre8">3.3&nbsp;&nbsp;&nbsp;&nbsp;
Utiliser
des templates</h2>
<p class="calibre4">Si vous avez déjà développé un site web, vous connaissez
sans doute le principe des templates. Le but est d'écrire la vue
(traditionnellement du HTML) séparément du code métier. Dans l'idéal,
un
webdesigner ne connaissant pas du tout le code métier (qu'il soit
JavaScript,
PHP, Ruby…) doit être capable d'écrire le template.</p>
<p class="calibre4">Concrètement, un langage de template se caractérise par deux
fonctions principales&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7">la substitution de variables&nbsp;: remplacer
par exemple «&nbsp;Bonjour #{name}&nbsp;»
par «&nbsp;Bonjour Jean&nbsp;» si la variablename
vaut «&nbsp;Jean&nbsp;»&nbsp;;</li>
  <li class="calibre7">l'utilisation de structures conditionnelles et
de boucles, dépendant notamment des variables données en paramètre.</li>
</ul>
<p class="calibre4">Les moteurs de template les plus avancés proposent des
fonctions bien plus évoluées comme l'application de fonctions aux
valeurs
affichées, de l'héritage de templates, etc.</p>
<p class="calibre4">Il existe plusieurs moteurs de templates utilisables avec
Node.js&nbsp;; j'ai choisi de vous présenter <em class="calibre5">Jade</em>,
d'une part parce
qu'Express permet de l'utiliser très facilement, et d'autre part parce
qu'il
dispose d'une syntaxe un peu particulière mais très efficace.</p>
<h3 id="calibre_link-32" class="calibre9">3.3.1&nbsp;&nbsp;&nbsp;
Présentation
du moteur de template Jade</h3>
<p class="calibre4">Le moteur de template Jade permet typiquement de générer une
page HTML, mais sa particularité est que les templates proprement dits
ne sont
pas écrits en HTML.</p>
<p class="calibre4">Commençons avec un exemple de template Jade, celui que nous
allons utiliser par la suite. Il s'agit quasiment du même exemple que
celui vu
précédemment, à l'exception qu'ici nous allons donner le choix à
l'utilisateur
entre plusieurs prénoms. (Révolutionnaire, non&nbsp;?)</p>
<div class="code1">
!!!<br class="calibre1"></br>
html<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; head<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
title= theTitle<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; body<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
div Choisir unprénom&nbsp;:<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- for name
intheNames<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
label<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
input(type="radio",name="name",value=name)<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
spanPrénom&nbsp;: #{name}<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
br<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
div<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
input(type="button",onclick="valid()",value="OK")<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#message<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
script(src="http://code.jquery.com/jquery-1.10.1.min.js")<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
script.<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
function valid() {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$.get('/hello/' + $('[name=name]:checked').val(),
function(data) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$('#message').html(data.message);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}, 'json');<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}
</div>
<p class="calibre4">Comme vous pouvez le remarquer, ça a le goût et l'odeur du
HTML, mais ça n'en est pas. Les balises type XML ont disparu au profit
d'une
organisation à base d'indentation.</p>
<p class="calibre4">Analysons pas à pas le contenu de ce template.</p>
<div class="code1">
!!!
</div>
<p class="calibre4">La première instruction <span class="code">!!!</span> sert à
insérer la déclaration du <em class="calibre5">doctype</em> de notre page
(celui de HTML5 par
défaut). Le code généré sera <span class="code">&lt;!DOCTYPE html&gt;</span>.</p>
<div class="code1">
html<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;head<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
title=theTitle
</div>
<p class="calibre4">Le document débute ensuite avec la déclaration de notre
balise <span class="code">html</span>,
puis de sa balise <span class="code">head</span>. Vous l'avez compris,
pour
déclarer une balise avec Jade (<span class="code">html, a, p</span>,
etc.), on commence la ligne avec le
nom de la balise.</p>
<p class="calibre4">Notre balise <span class="code">title</span> a une petite
particularité&nbsp;: on a écrit <span class="code">title=</span> et
non <span class="code">title</span>.
Cela indique à Jade que le contenu de la balise n'est pas le texte qui
suit,
mais le contenu de la variable dont le nom est indiqué, ici <span class="code">theTitle</span>,
que nous donnerons un peu plus tard à Jade pour qu'il génère le HTML.</p>
<p class="calibre4">Si on avait voulu déclarer un titre statique (ne dépendant
pas d'une variable), on aurait pu écrire&nbsp;: <span class="code">title
Hello!</span>.</p>
<div class="code1">
body<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; div Choisir un prénom&nbsp;:
</div>
<p class="calibre4">Nous attaquons ensuite le corps de la page avec la balise <span class="code">body</span>.
Son
premier élément est une balise div, dont le contenu est
«&nbsp;Choisir un prénom&nbsp;».</p>
<div class="code1">
- for name in theNames<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; label<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
input(type="radio",name="name",value=name)<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
span Prénom : #{name}<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;br
</div>
<p class="calibre4">Nouvelle instruction particulière ensuite, la ligne commence
par le symbole <span class="code">-</span> (tiret haut). Cela indique à
Jade
qu'il s'agit d'une instruction conditionnelle ou de boucle, ici <span class="code">for</span>.
Sa syntaxe
est relativement similaire à ce que l'on voit dans d'autres langages : <span class="code">-
for var element
in tableau</span> permet de parcourir les éléments du tableau
tableau
et définissant à chaque itération la variable element.</p>
<p class="calibre4">Dans notre exemple le tableau à parcourir est <span class="code">theNames</span>,
variable que nous allons fournir à Jade pour la génération, comme pour
theTitle
vue plus haut.</p>
<p class="calibre4">Donc pour chaque élément de <span class="code">theNames</span>,
nous allons générer une balise label, qui contiendra elle-même deux
balises, un
bouton-radio et un libellé.</p>
<p class="calibre4">Le bouton radio (en HTML <span class="code">&lt;input
type="radio"...</span>)
possède trois attributs qui sont définis dans Jade à l'aide de
parenthèses.
Notez que pour les attributs <span class="code">type</span> et <span class="code">name</span>
les valeurs sont entre
guillemets doubles car elles sont statiques. En revanche, <span class="code">value=name</span>
indique que Jade soit substituer name par la valeur de la variable <span class="code">name</span>.

<p class="calibre4">Le libellé est déclaré par l'instruction <span class="code2">span
Prénom&nbsp;: #{name}</span>. Si nous
avions voulu que le libellé soit simplement le prénom à choisir, nous
aurions
écrit <span class="code2">span=name</span>.
Mais la syntaxe que nous utilisons ici permet d'intégrer le contenu de
la
variable au sein de contenu statique. Ici, <span class="code2">#{name}
</span>
sera
substitué par la valeur de la variable <span class="code2">name</span>.</p>
<div class="code3">
script(src="http://code.jquery.com/jquery-1.10.1.min.js")<br class="calibre1"></br>
script.<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; function valid() {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$.get('/hello/' + $('[name=name]:checked').val(),
function(data) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$('#message').html(data.message);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}, 'json');<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; }
</div>
<p class="calibre4">Rien de plus à dire ici, si ce n'est l'utilisation de la
balise <span class="code2">script.</span>,
avec le point à la fin. Cette syntaxe, utilisée avec les balises <span class="code2">script
</span>
et <span class="code2">style</span> permet
d'indiquer à Jade qu'il ne faut pas interpréter le contenu de la balise
(le
JavaScript et le CSS ne sont en effet pas soumis à l'interprétation de
Jade).</p>
<p class="calibre4">Voilà pour ce qui est de notre petite introduction à Jade.
Ses possibilités vont bien au-delà de ce qui a été présenté, mais cela
devrait suffir pour comprendre la suite, notamment l'utilisation de
templates avec Node.js en général, et plus spécifiquement avec Express.
J'espère aussi que cela vous a donné envie d'aller plus loin dans la
découverte
de Jade&nbsp;; la syntaxe est déroutante, mais dès que les fichiers
deviennent
conséquents la maintenance est beaucoup plus aisée que pour du HTML
classique.</p>
<p class="calibre4">Voyons maintenant comment utiliser ce template au sein de
notre application Express.</p>
<h3 id="calibre_link-33" class="calibre11">3.3.2&nbsp;&nbsp;&nbsp;
Utiliser
Jade avec Express</h3>
<p class="calibre4">La première chose à faire est d'installer le module Jade,
comme nous l'avons fait avec Express&nbsp;:</p>
<div class="code3">
npm install jade
</div>
<p class="calibre4">À présent, le code de notre programme révolutionnaire, qui
s'est encore un peu simplifié&nbsp;:</p>
<div class="code3">
var express =require('express');<br class="calibre1"></br>
varfs = require('fs');<br class="calibre1"></br>
<br class="calibre1"></br>
varapp = express();<br class="calibre1"></br>
app.set('viewengine',
'jade');<br class="calibre1"></br>
app.set('views', __dirname);<br class="calibre1"></br>
<br class="calibre1"></br>
app.get('/',function(req,
res){<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.render('express02',
{title: 'Hello', names: [
'Pierre', 'Paul', 'Jacques' ] });<br class="calibre1"></br>
});<br class="calibre1"></br>
<br class="calibre1"></br>
app.get('/hello/:name', function(req,res){<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.writeHead(200,
{'Content-Type': 'application/json'});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;res.end(JSON.stringify({message: 'Hello '
+ req.params.name +
'!'}));<br class="calibre1"></br>
});<br class="calibre1"></br>
<br class="calibre1"></br>
app.listen(8080);
</div>
<p class="calibre4">Première remarque&nbsp;: il n'est pas nécessaire d'inclure
le module <em class="calibre5">jade</em> avec une instruction <span class="code2">require</span>.
Express s'en charge lorsque nous déclarons le moteur de template que
nous
souhaitons utiliser&nbsp;:</p>
<div class="code3">
app.set('view engine', 'jade');<br class="calibre1"></br>
app.set('views', __dirname);
</div>
<p class="calibre4">La deuxième instruction sert ici à déclarer que nos
templates se trouvent dans le même répertoire que les sources du
programme (<span class="code2">__dirname</span>).
Il va de soi que pour un programme plus conséquent il est judicieux
d'avoir un
répertoire (voire une arborescence) dédié aux templates.</p>
<p class="calibre4">La seule différence ensuite, par rapport à la version
précédente, est cette ligne&nbsp;:</p>
<div class="code3">
res.render('express02', { title: 'Hello',names: [
'Pierre', 'Paul', 'Jacques' ] });
</div>
<p class="calibre4">Nous indiquons ici à Express qu'il doit&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7">utiliser le template <em class="calibre5">express02</em>&nbsp;:
pour cela il va chercher le fichier <em class="calibre5">express02.jade</em>
dans le répertoire
courant comme nous le lui avons indiqué&nbsp;;</li>
  <li class="calibre7">lui passer en paramètres les données <span class="code2">title
</span>
et <span class="code2">names</span>,
la première étant une chaîne et la deuxième un tableau.</li>
</ul>
<p class="calibre4">Le tout en une ligne&nbsp;! Si vous lancez le programme et
appelez l'URL <em class="calibre5">http://localhost:8080/</em>, vous
pourrez observer une page
dont le titre est «&nbsp;Hello&nbsp;» (variable <span class="code2">title</span>),
et contenant trois boutons radio, un pour chaque prénom que nous avons
mis dans
la variable names.</p>
<p class="calibre4">Maintenant que nous avons découvert les bases d'Express et
de Jade, voyons comment Express peut nous simplifier la tâche dans le
cadre
d'applications plus complexes, composées de plusieurs pages.</p>
<h2 id="calibre_link-34" class="calibre12">3.4&nbsp;&nbsp;&nbsp;&nbsp;
Une
application Express plus complexe</h2>
<p class="calibre4">Nous avons vu dans les parties précédentes comment créer une
application minimaliste avec Express. Mais que se passe-t-il lorsque
votre
application (ou site) est composée de plusieurs pages par
exemple&nbsp;? Il est
alors nécessaire d'organiser les sources de manière à ce que l'ensemble
reste
lisible et maintenable. Pour cela, Express peut nous rendre service en
créant
automatiquement une belle arborescence. Cela nous fait gagner du temps,
mais
permet surtout de comprendre les bonnes pratiques concernant
l'organisation
d'une application constituée de plusieurs scripts, templates, etc.</p>
<p class="calibre4">Pour cela, il est d'abord nécessaire d'installer le module <em class="calibre5">express</em>,
mais de manière <em class="calibre5">globale</em>, c'est à dire de sorte à
rendre ce module
utilisable par n'importe quelle application Node.js sur le système, et
non juste
pour l'application du répertoire courant. Cela se fait par la
commande&nbsp;:</p>
<div class="code3">
npm install -g express
</div>
<p class="calibre4">En tapant ensuite la commande <span class="code2">express</span>,
vous pourrez vérifier si le
module a bien été installé.</p>
<p class="calibre4">Pour créer ensuite un projet Express, rendez-vous en ligne de
commande dans le répertoire parent qui accueillera votre répertoire
projet,
puis tapez la commande&nbsp;:</p>
<div class="code3">
express express03
</div>
<p class="calibre4">(express03 est ici le nom à donner
au projet.) Express a donc créé un répertoire <span class="code2">express03</span>,
dont l'arborescence contient
des sources et plusieurs répertoires&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7"><em class="calibre5">public/</em>&nbsp;: contient les
fichiers
'ressources' de l'application web&nbsp;: CSS, JavaScript client,
images,
etc.&nbsp;;</li>
  <li class="calibre7"><em class="calibre5">routes/</em>&nbsp;: contient les <em class="calibre5">routes</em>,
c'est à dire les sous-modules de notre application&nbsp;;</li>
  <li class="calibre7"><em class="calibre5">views</em><em class="calibre5">/</em>&nbsp;:
contient les vues de notre application, c'est à dire les modèles
Jade&nbsp;;</li>
  <li class="calibre7"><em class="calibre5">app.js</em> le point d'entrée de
l'application
;</li>
  <li class="calibre7"><em class="calibre5">package.json</em>
fichier contenant lesméta-données de l'application,
les dépendances, etc.</li>
</ul>
<p class="calibre4">Premier fichier intéressant, le fichier <em class="calibre5">package.json</em>.</p>
<div class="code3">
{<br class="calibre1"></br>
&nbsp; "name": "application-name",<br class="calibre1"></br>
&nbsp; "version": "0.0.1",<br class="calibre1"></br>
&nbsp; "private": true,<br class="calibre1"></br>
&nbsp; "scripts": {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; "start": "node
app.js"<br class="calibre1"></br>
&nbsp; },<br class="calibre1"></br>
&nbsp; "dependencies": {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; "express":
"3.4.0",<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; "jade": "*"<br class="calibre1"></br>
&nbsp; }<br class="calibre1"></br>
}
</div>
<p class="calibre4">Il permet d'y placer les métadonnées concernant notre
application&nbsp;: le nom, l'auteur, la version, etc. Cela peut
être très utile
si vous décidez de distribuer votre application. Mais ces données ne
servent
pas «&nbsp;qu'à faire joli&nbsp;»&nbsp;: le bloc <span class="code2">dependencies</span>
permet d'indiquer les dépendances de votre application, autrement dit
les
modules requis pour la faire fonctionner. Ici, nous avons besoin du
module <em class="calibre5">express</em>
en version 3.4.0, et du module <em class="calibre5">jade</em>, dans la
dernière version
disponible.</p>
<p class="calibre4">Afin d'installer automatiquement les dépendances de
l'application en se basant sur les informations du <em class="calibre5">package.json</em>,
tapez la commande&nbsp;:</p>
<div class="code3">
npm install
</div>
<p class="calibre4">Nous reviendrons en détail sur les possibilités offertes par
ce fichier dans le chapitre 5.</p>
<p class="calibre4">Analysons à présent le contenu du fichier principal&nbsp;:
<em class="calibre5">app.js</em>.</p>
<div class="code3">
var express = require('express');<br class="calibre1"></br>
var routes = require('./routes');<br class="calibre1"></br>
var user = require('./routes/user');<br class="calibre1"></br>
var http = require('http');<br class="calibre1"></br>
var path = require('path');<br class="calibre1"></br>
<br class="calibre1"></br>
var app = express();<br class="calibre1"></br>
<br class="calibre1"></br>
app.set('port',process.env.PORT ||
3000);<br class="calibre1"></br>
app.set('views', __dirname + '/views');<br class="calibre1"></br>
app.set('view engine', 'jade');<br class="calibre1"></br>
app.use(express.static(path.join(__dirname, 'public')));<br class="calibre1"></br>
<br class="calibre1"></br>
app.get('/',routes.index);<br class="calibre1"></br>
app.get('/users',user.list);<br class="calibre1"></br>
<br class="calibre1"></br>
http.createServer(app).listen(app.get('port'),
function(){<br class="calibre1"></br>
&nbsp; console.log('Express server listening on port '
+app.get('port'));<br class="calibre1"></br>
});
</div>
<p class="calibre4">J'ai volontairement retiré quelques lignes du fichier afin
de faciliter l'explication. Globalement peu de nouveautés dans ce
fichier. On
initialise un objet application (<span class="code2">app</span>) dont on
configure le port à
écouter (<span class="code2">app.set('port',...)</span>),
le moteur de template (Jade) ainsi que le répertoire où ces templates
sont
stockés (le sous-répertoire <em class="calibre5">views</em>), et enfin
le répertoire des ressources «&nbsp;statiques&nbsp;» (le
sous-répertoire <em class="calibre5">public</em>).</p>
<p class="calibre4">Les trois dernières lignes sont une méthode un peu
différente de lancer le serveur par rapport à ce que nous avions vu,
mais cela
revient globalement au même.</p>
<p class="calibre4">La nouveauté réside ici dans les lignes suivantes&nbsp;:</p>
<div class="code3">
var routes = require('./routes');<br class="calibre1"></br>
var user = require('./routes/user');<br class="calibre1"></br>
<br class="calibre1"></br>
app.get('/',routes.index);<br class="calibre1"></br>
app.get('/users',user.list);
</div>
<p class="calibre4">En réalité, nous ne faisons qu'appeler la fonction get
comme nous le faisions déjà, mais plutôt que de lui donner la fonction
directement lors de l'appel, nous lui donnons une référence vers la
fonction
déclarée ailleurs. Les fonctions <span class="code2">routes.index</span>
et <span class="code2">user.list</span> sont définies respectivement
dans
les fichiers <em class="calibre5">routes/index.js</em> et <em class="calibre5">routes/user.js</em>.</p>
<p class="calibre4">La syntaxe permettant d'inclure des fichiers comme cela est
fait ici sera détaillée dans le chapitre 5
consacré à la création de modules. Le contenu des fichiers inclus est
très
simple&nbsp;:</p>
<div class="code3">
// routes/index.js<br class="calibre1"></br>
exports.index =function(req,
res){<br class="calibre1"></br>
&nbsp;res.render('index', {
title: 'Express' });<br class="calibre1"></br>
};<br class="calibre1"></br>
<br class="calibre1"></br>
// routes/user.js<br class="calibre1"></br>
exports.list =function(req,
res){<br class="calibre1"></br>
&nbsp;res.send("respondwith a resource");<br class="calibre1"></br>
};
</div>
<p class="calibre4">Dans le premier cas, nous appelons le modèle <em class="calibre5">index</em>
(situé dans <span class="code2">_views/index.jade</span>),
et dans le deuxième nous renvoyons un message texte.</p>
<p class="calibre4">La nouveauté dans cette application réside dans le modèle <em class="calibre5">index.jade</em>
:</p>
<div class="code3">
extends layout<br class="calibre1"></br>
<br class="calibre1"></br>
block content<br class="calibre1"></br>
&nbsp; h1= title<br class="calibre1"></br>
&nbsp; p Welcome to #{title}
</div>
<p class="calibre4">Pas de structure HTML classique ici, seulement deux
instructions principales&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7"><span class="code2">extends layout</span>&nbsp;:
on déclare que notre modèle <span class="code2">index</span> hérite en
quelques sortes du modèle <span class="code2">layout</span>. Autrement
dit, la page sera basée sur le modèle <span class="code2">layout</span>&nbsp;;</li>
  <li class="calibre7"><span class="code2">block content</span>&nbsp;: partant
du template <em class="calibre5">layout</em>, on remplira le bloc <span class="code2">content</span>
par le
contenu inscrit ici (un titre h1 et une ligne de texte p).</li>
</ul>
<p class="calibre4">Si l'on observe le template <span class="code2">layout</span>,
on remarque la présence du bloc <span class="code2">content</span> (<span class="code2">block
content</span>)&nbsp;: c'est lui qui sera
rempli avec le code contenu dans <em class="calibre5">index.jade</em>&nbsp;:</p>
<div class="code3">
doctype 5<br class="calibre1"></br>
html<br class="calibre1"></br>
&nbsp; head<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; title= title<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;
link(rel='stylesheet',href='/stylesheets/style.css')<br class="calibre1"></br>
&nbsp; body<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; block content
</div>
<p class="calibre4">Nous aurions pu regrouper le tout dans un seul fichier sans
faire appel aux <em class="calibre5">blocks</em> de Jade en plaçant le h1
et le p directement dans la balise body&nbsp;;
l'intérêt est que lorsqu'on a plusieurs pages, on peut utiliser le même
<em class="calibre5">layout</em>, c'est à dire la même architecture, le même
design, le même en-tête, etc. de page.</p>
<h2 id="calibre_link-35" class="calibre12">3.5&nbsp;&nbsp;&nbsp;&nbsp;
Exercice</h2>
<p class="calibre4">Afin de mettre en pratique ce que nous venons de voir, je
vous propose l'exercice suivant&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7">reprendre l'exemple que nous venons de
voir&nbsp;;</li>
  <li class="calibre7">ajouter une page accessible à l'adresse <em class="calibre5">/hello</em>,
et ayant en commun avec la page d'accueil une barre de menu contenant
deux
liens&nbsp;: un vers la page d'accueil et un vers la nouvelle
page&nbsp;;</li>
  <li class="calibre7">sur la nouvelle page, ajouter le formulaire que
nous avons vu au début du chapitre demandant son nom à
l'utilisateur&nbsp;;</li>
  <li class="calibre7">au clic sur le bouton <em class="calibre5">OK</em> du
formulaire,
l'application effectuera un appel AJAX à l'URL <em class="calibre5">/hello/sayHello/?name=LePrenomSaisi</em>
qui renverra au format JSON un message de salutation, qui sera affiché
sur la
page.</li>
</ul>
<h2 id="calibre_link-36" class="calibre12">3.6&nbsp;&nbsp;&nbsp;&nbsp;
En résumé</h2>
<p class="calibre4">Nous avons vu dans ce chapitre comment créer une application
web bien structurée. Encore une fois, l'objectif d'Express (et de Node
en
général) n'est pas de concurrencer des frameworks comme Symfony ou Ruby
on
Rails, qui seront beaucoup plus adaptés pour créer des applications
complexes.</p>
<p class="calibre4">Express se montrera en revanche parfaitement adapté pour
créer une application proposant deswebservices REST,
ou encore un petit site vitrine disposant de quelques fonctionnalités
dynamiques (formulaire de contact, catalogue de produits, etc.).</p>
<p class="calibre4">L'un des avantages d'Express est qu'il permet de s'adapter à
plusieurs modules de gestion de templates, mais aussi à des modules de
test
unitaire ou test web, d'accès à des bases de données, etc. Et il faut
bien le
reconnaître, sa mise en place est tout de même beaucoup plus facile que
celle
de Symfony&nbsp;!</p>

</div></div>

<div class="calibre" id="calibre_link-3">

<h1 id="calibre_link-37" class="calibre13">Chapitre
4 :
Utiliser des bases
de données</h1>
<p class="calibre4">Dans la plupart des applications que nous développons, il
est nécessaire d'avoir un mécanisme de persistance des données, et le
moyen le
plus robuste et le plus employé est d'utiliser une base de données.
Avec
Node.js, l'objectif n'est pas de faire appel aux gros systèmes de
gestion de
base de données comme MySQL ou Oracle (bien que cela soit possible, on
préfèrera passer par l'intermédiaire d'une API ou d'un webservice
externe pour
cela), mais utiliser un système plus souple et plus léger.</p>
<p class="calibre4">Nous verrons dans ce chapitre deux système
fréquemment utilisés avec Node.js. Le premier est <em class="calibre5">SQLite3</em>,
dont le
principe est de stocker une base dans un fichier, et d'y accéder grâce
au
langage SQL. Le second, <em class="calibre5">MongoDB</em> est radicalement
différent&nbsp;; les
données qui y sont stockées ressemblent étrangement à du format JSON,
c'est-à-dire que les données sont organisées hiérarchiquement et non
sous forme
de tables. Il fait partie de la famille des systèmes de gestion de base
de
données <em class="calibre5">NoSQL</em><em class="calibre5"> (Not Only
SQL)</em>.</p>
<h2 id="calibre_link-38" class="calibre12">4.1&nbsp;&nbsp;&nbsp;&nbsp;
Sqlite3</h2>
<h3 id="calibre_link-39" class="calibre11">4.1.1&nbsp;&nbsp;&nbsp;
Présentation</h3>
<p class="calibre4">Créé initialement pour être intégré dans des systèmes de
missiles au début des années 2000, SQLite est un système de gestion de
bases de
données ultraléger dont le principal intérêt est qu'il ne nécessite pas
de
serveur. Une base de données n'est qu'un fichier stocké localement.
Notamment,
il n'y a pas de gestion d'utilisateurs&nbsp;: si un programme a le
droit
d'accéder au fichier, alors il peut accéder à la base de données.</p>
<p class="calibre4">Cela rend SQLite relativement facile à prendre en main et à
maintenir. Son utilisation principale n'est pas la gestion de grosses
base de
données métier, on réservera cela aux gros MySQL, Oracle, SQL
Server…Mais il
est extrêmement utilisé par exemple pour stocker des données de
configuration,
ou encore des données mises en cache, pour soulager la base de données
principale d'un gros système. Notamment, SQLite est extrêmement utilisé
dans
les applications mobiles (iPhone notamment)&nbsp;: on imagine mal
un serveur
MySQL tourner sur un mobile, mais une base de données
SQLite permet un accès plus facile aux données stockées que si elles
l'étaient
dans des fichiers.</p>
<p class="calibre4">L'utilisation de SQLite avec Node.js se fait avec le module <em class="calibre5">sqlite3</em>
: <span class="code2">npm install sqlite3</span>. Rien à installer à
part ça, SQLite ne requiert pas de
serveur&nbsp;!</p>
<h3 id="calibre_link-40" class="calibre11">4.1.2&nbsp;&nbsp;&nbsp;
Premier exemple</h3>
<p class="calibre4">Une fois le module installé, passons à un exemple très
simple&nbsp;:</p>
<div class="code3">
var sqlite3 = require('sqlite3');<br class="calibre1"></br>
vardb = new
sqlite3.Database(':memory:');<br class="calibre1"></br>
<br class="calibre1"></br>
db.serialize(function() {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;db.run("create
table users (login, name)");<br class="calibre1"></br>
<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; varstmt
=db.prepare("insert into users values
(?,&nbsp;?)");<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; var users = [ { login:
'pierre',&nbsp; name: 'Pierre'&nbsp; },<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ login: 'paul',&nbsp;&nbsp;&nbsp; name:
'Paul'&nbsp;&nbsp;&nbsp; },<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ login: 'jacques', name: 'Jacques' } ];<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; for (vari
in users) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
stmt.run(users[i].login, users[i].name);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; }<br class="calibre1"></br>
<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;db.each("select
login, name from users", function(err, row) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console.log(row.login + ": " + row.name);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; });<br class="calibre1"></br>
});
</div>
<p class="calibre4">Comme à l'habitude, nous commençons par inclure notre module
fraîchement installé <em class="calibre5">sqlite3</em>.</p>
<div class="code3">
var db = new sqlite3.Database(':memory:');
</div>
<p class="calibre4">Nous créons ensuite un objet <em class="calibre5">Database</em>
sur lequel nous effectuerons nos requêtes. Le paramètre est le nom du
fichier
de base de données que nous souhaitons utiliser&nbsp;; pour nos
premiers tests,
<span class="code2">
':memory:'
</span>
nous permet d'utiliser une base temporaire qui sera détruite à la fin
de
l'exécution. Ce n'est bien entendu que pour faciliter la
compréhension&nbsp;;
peu d'intérêt dans une application finale.</p>
<div class="code3">
db.serialize(function() {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; ...<br class="calibre1"></br>
});
</div>
<p class="calibre4">Nous englobons le code de notre application dans une fonction
que nous passons en paramètre la méthode <span class="code2">serialize
</span>
de notre objet <span class="code2">db</span>. Cela nous permet
d'indiquer
que les requêtes qui sont exécutées dans cette fonction doivent être
exécutées
de manière séquentielle, c'est-à-dire l'une après l'autre (en
opposition au
mode parallèle dans lequel toutes les requêtes sont exécutées en même
temps).</p>
<div class="code3">
db.run("create table users (login, name)");
</div>
<p class="calibre4">Ici, grâce à la méthode <span class="code2">db.run</span>,
nous exécutons une simple requête SQL, en l'occurrence nous créons une
table <em class="calibre5">users</em> composée de deux colonnes&nbsp;: <em class="calibre5">login</em>
et <em class="calibre5">name</em>. Notez que SQLite n'est pas très
exigent sur le typage des données. Par défaut, les colonnes sont de
type <em class="calibre5">chaîne</em>.</p>
<div class="code3">
var stmt
= db.prepare("insert into
users values (?,&nbsp;?)");<br class="calibre1"></br>
var users = [ { login:
'pierre',&nbsp;name: 'Pierre'&nbsp; },<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ login: 'paul',&nbsp;&nbsp;&nbsp; name:
'Paul'&nbsp;&nbsp;&nbsp; },<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ login: 'jacques',name: 'Jacques' } ];<br class="calibre1"></br>
for (var i in users) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;stmt.run(users[i].login,users[i].name);<br class="calibre1"></br>
}
</div>
<p class="calibre4">Nous créons ensuite un <em class="calibre5">statement</em>,
ce que l'on peut voir comme un modèle de requête. En effet dans la
requête insert, les
points d'interrogation seront remplacés par des valeurs qui seront
automatiquement mises au bon format (avec les guillemets, les
caractères
d'échappement…).</p>
<p class="calibre4">Les données que nous allons insérer dans notre table <em class="calibre5">users</em>
sont contenues dans le tableau <span class="code2">users</span>.
Nous bouclons donc sur les éléments de ce tableau, puis pour chacun
nous
appelons la méthode stmt.run, ce qui aura pour
conséquence d'utiliser la requête (le <em class="calibre5">statement</em>)
que nous venons de définir, en utilisant les bonnes valeurs, passées en
paramètre.</p>
<div class="code3">
db.each("select login, name from users",
function(err, row) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; console.log(row.login
+ ": " + row.name);<br class="calibre1"></br>
});
</div>
<p class="calibre4">Après avoir inséré nos valeurs dans la base, nous allons les
lire, en utilisant la méthode <span class="code2">db.each</span>. Cette
méthode exécute
une requête, mais contrairement à <span class="code2">db.run</span> que
nous avons vue plus
haut, celle-ci nous permet de récupérer le résultat de son exécution,
en
l'occurrence les enregistrements retournés.</p>
<p class="calibre4">Pour cela, nous fournissons à <span class="code2">db.each</span>
une fonction de rappel qui sera exécutée pour chaque enregistrement
renvoyé,
enregistrement qui sera passé en second paramètre, le premier étant
l'erreur
éventuelle.</p>
<p class="calibre4">Il existe également une méthode <span class="code2">db.all</span>
qui permet d'accéder à tous les résultats de la requête en même temps,
ce qui
peut être utile pour compter les résultats par exemple, ou encore pour
effectuer un traitement sur plusieurs résultats à la fois.</p>
<p class="calibre4">Exécutons notre exemple&nbsp;:</p>
<div class="code3">
$ node
sqlite01.js<br class="calibre1"></br>
pierre: Pierre<br class="calibre1"></br>
paul: Paul<br class="calibre1"></br>
jacques: Jacques
</div>
<h3 id="calibre_link-41" class="calibre11">4.1.3&nbsp;&nbsp;&nbsp;
Deuxième exemple</h3>
<p class="calibre4">Dans ce deuxième exemple à peine plus complexe, nous allons
cette fois-ci utiliser un fichier où stocker notre base de données
SQLite. Le
but sera de stocker les dates et heures d'appel du script dans cette
base, afin
de les afficher à chaque exécution.</p>
<div class="code3">
var sqlite3 = require('sqlite3');<br class="calibre1"></br>
vardb = new
sqlite3.Database('sqlite02.db');<br class="calibre1"></br>
<br class="calibre1"></br>
db.serialize(function() {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;db.run("create
table if not exists log (date)");<br class="calibre1"></br>
<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;db.all("select
date from log", function(err, rows) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if( rows.length == 0 )<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console.log("Premièreexécution&nbsp;!");<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for( vari in rows )<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console.log(rows[i].date);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; });<br class="calibre1"></br>
<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; var date = new Date().toLocaleString();<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; varstmt
=db.prepare("insert into log values (?)");<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;stmt.run(date);
<br class="calibre1"></br>
});
</div>
<p class="calibre4">Nous utilisons à présent le fichier <em class="calibre5">sqlite02.db</em>
pour
stocker nos données, où nous créons une table <em class="calibre5">log</em>
si celle-ci n'existe
pas déjà (if not exists). La table ne contient qu'un seul
champ&nbsp;: <em class="calibre5">date</em>.</p>
<p class="calibre4">Nous commençons par exécuter la requête <span class="code2">select
date from log</span> qui nous renvoie
les dates d'exécution du script. S'il n'y a pas
d'enregistrements renvoyés (<span class="code2">rows.length == 0</span>),
nous
affichons qu'il s'agit de la première exécution du script. Sinon, nous
affichons les dates.</p>
<p class="calibre4">Puis nous insérons en base la date courante afin que
celle-ci soit affichée pour les prochaines exécutions.</p>
<p class="calibre4">Si vous exécutez ce script plusieurs fois, vous aurez un
affichage similaire à celui-ci&nbsp;:</p>
<div class="code3">
$ node
sqlite02.js<br class="calibre1"></br>
Première exécution&nbsp;!<br class="calibre1"></br>
$ node sqlite02.js<br class="calibre1"></br>
Fri Sep 13 2013 13:10:40 GMT+0200 (Paris, Madrid (heure d'été))<br class="calibre1"></br>
$ node sqlite02.js<br class="calibre1"></br>
Fri Sep 13 2013 13:10:40 GMT+0200 (Paris, Madrid (heure d'été))<br class="calibre1"></br>
Fri Sep 13 2013 13:10:55 GMT+0200 (Paris, Madrid (heure d'été))
</div>
<h3 id="calibre_link-42" class="calibre11">4.1.4&nbsp;&nbsp;&nbsp;
Aller
plus loin avec un ORM</h3>
<p class="calibre4">Si vous avez déjàdévéloppé des
applications utilisant une base de données SQL, vous n'êtes pas sans
savoir
qu'il peut être pénible d'avoir à se soucier des requêtes SQL, de leur
syntaxe,
notamment lorsqu'il s'agit de faire des requêtes sur plusieurs tables
en même
temps.</p>
<p class="calibre4">On préfère donc utiliser par exemple un ORM <em class="calibre5">(object-relational
mapping)</em>
qui permet de traiter les données en base comme des objets. Par
exemple, avec
l'ORM <em class="calibre5">Sequelize</em> (http://sequelizejs.com)
nous pouvons définir un modèle <em class="calibre5">User</em> correspondant
à la table <em class="calibre5">users</em> utilisée dans notre premier
exemple&nbsp;:</p>
<div class="code3">
var User = sequelize.define('User', {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; login: { type:Sequelize.STRING,
primaryKey: true },<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; name:Sequelize.STRING<br class="calibre1"></br>
});
</div>
<p class="calibre4">Sequelize peut ensuite créer automatiquement notre
table&nbsp;:</p>
<div class="code3">
User.sync();
</div>
<p class="calibre4">Puis nous pouvons requêter sur nos utilisateurs grâce à la
méthode <span class="code2">find</span>.</p>
<div class="code3">
User.find('pierre').success(function(user)
{<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; console.log(user.values.name);<br class="calibre1"></br>
});
</div>
<p class="calibre4">Sequelize permet de manipuler d'autres bases de données
qu'SQLite comme MySQL ou PostgreSQL, et il existe
d'autres ORM disponibles. N'hésitez pas rechercher celui qui
correspondra le
mieux à vos besoins.</p>
<h2 id="calibre_link-43" class="calibre12">4.2&nbsp;&nbsp;&nbsp;&nbsp;
MongoDB</h2>
<p class="calibre4">MongoDB se distingue des systèmes de gestion de base de
données traditionnels par le type d'objet qu'il peut stocker et sa
manière de
les stocker. Ici pas de tables et de relations (comme des clés
étrangères).
Vous stockez des objets constitués de propriétés, dont les valeurs
peuvent être
d'autres objets. Cela vous rappelle quelque chose&nbsp;? Oui, c'est
ouvertement
inspiré des objets JavaScript auxquels vous devez commencer à être
habitués&nbsp;!</p>
<h3 id="calibre_link-44" class="calibre11">4.2.1&nbsp;&nbsp;&nbsp;
Le shell de MongoDB</h3>
<p class="calibre4">Première chose à faire&nbsp;: installer MongoDB. Vous
pouvez
utiliser le gestionnaire de paquets de votre système, ou bien
télécharger le
programme sur le site de MongoDB (http://www.mongodb.org/).</p>
<p class="calibre4">Une fois installé, vous pouvez lancer le shell de MongoDB
par la commande <span class="code2">mongo</span>.
Créons notre première base de données, et appelons-la mabase&nbsp;:</p>
<div class="code3">
&gt; usemabase;<br class="calibre1"></br>
switched todb mabase<br class="calibre1"></br>
&gt;db<br class="calibre1"></br>
mabase
</div>
<p class="calibre4">Comme vous le voyez, pour créer une base il suffit de
vouloir l'utiliser&nbsp;! Une fois que vous avez déclaré à Mongo
que vous
souhaitiez utiliser la base <span class="code2">mabase</span>, c'est par
l'objet <span class="code2">db</span>
que vous y accédez.</p>
<p class="calibre4">Commençons par insérer quelques données dans notre
base&nbsp;:</p>
<div class="code3">
&gt;db.utilisateurs.save({
nom: 'Pierre', adresse: { voie: 'Avenue des Rues', ville: 'Rennes' } });<br class="calibre1"></br>
&gt;db.utilisateurs.save({
nom: 'Jacques', adresse: { voie: 'Rue des Avenues', ville: 'Paris' } });<br class="calibre1"></br>
&gt;db.utilisateurs.save({
nom: 'Paul' });
</div>
<p class="calibre4">Pour ce qui est de la terminologie Mongo, nous venons ici
d'insérer trois <em class="calibre5">documents</em> dans une <em class="calibre5">collection</em>.
Vous constaterez
que les documents d'une collection peuvent être hétérogènes&nbsp;;
évidemment
il vaut mieux éviter qu'ils le soient trop.</p>
<p class="calibre4">Pour vérifier le contenu de notre collection, nous utilisons
la méthode <span class="code2">find</span> de l'objet <span class="code2">db</span>,
à
laquelle nous pouvons donner des critères de recherche.</p>
<div class="code3">
&gt;db.utilisateurs.find();<br class="calibre1"></br>
{ "_id"&nbsp;:ObjectId("5238b1c15fe1afba9cec2027"),
"nom"&nbsp;: "Pierre", "adresse"&nbsp;: {
"voie"&nbsp;: "Avenue des Rues", "ville"&nbsp;:
"Rennes" } }<br class="calibre1"></br>
{ "_id"&nbsp;:ObjectId("5238b1c95fe1afba9cec2028"),
"nom"&nbsp;: "Jacques", "adresse"&nbsp;: {
"voie"&nbsp;: "Rue des Avenues", "ville"&nbsp;:
"Paris" } }<br class="calibre1"></br>
{ "_id"&nbsp;:ObjectId("5238b1d05fe1afba9cec2029"),
"nom"&nbsp;: "Paul" }<br class="calibre1"></br>
<br class="calibre1"></br>
&gt;db.utilisateurs.find({
nom: 'Pierre' });<br class="calibre1"></br>
{ "_id"&nbsp;:ObjectId("5238b1c15fe1afba9cec2027"),
"nom"&nbsp;: "Pierre", "adresse"&nbsp;: {
"voie"&nbsp;: "Avenue des Rues", "ville"&nbsp;:
"Rennes" } }<br class="calibre1"></br>
<br class="calibre1"></br>
&gt;db.utilisateurs.find({
'adresse.ville': 'Paris' });<br class="calibre1"></br>
{ "_id"&nbsp;:ObjectId("5238b1c95fe1afba9cec2028"),
"nom"&nbsp;: "Jacques", "adresse"&nbsp;: {
"voie"&nbsp;: "Rue des Avenues", "ville"&nbsp;:
"Paris" } }
</div>
<p class="calibre4">Pour mettre à jour un document, nous utilisons la méthode <span class="code2">update</span>&nbsp;:</p>
<div class="code3">
&gt;db.utilisateurs.update(
{ nom: 'Paul' }, { nom: 'Paul', nb: 3 } );<br class="calibre1"></br>
&gt;db.utilisateurs.find( {
nom: 'Paul' } );<br class="calibre1"></br>
{ "_id"&nbsp;:ObjectId("5238b1d05fe1afba9cec2029"),
"nom"&nbsp;: "Paul", "nb"&nbsp;: 3 }
</div>
<p class="calibre4">À présent que vous connaissez les bases de MongoDB, voyons
comment utiliser tout ça avec Node.js.</p>
<h3 id="calibre_link-45" class="calibre11">4.2.2&nbsp;&nbsp;&nbsp;
MongoDB
avec Node.js&nbsp;: Mongoose</h3>
<p class="calibre4">Il existe plusieurs modules permettant d'accéder à MongoDB
en Node.js. Le module de base est <em class="calibre5">mongodb</em>, qui
fournit une
interface permettant d'effectuer des opérations sur une base de la même
manière
que nous venons de le faire avec le shell <em class="calibre5">mongo</em>.
Le module <em class="calibre5">mongoose</em>
est un autre module officiel, qui en se basant sur mongodb
introduit une couche supplémentaire facilitant la manipulation des
données
grâce à une couche ODM <em class="calibre5">(object-document mapper)</em>,
équivalent pour les documents des ORM <em class="calibre5">(object-relational
mapper)</em>.</p>
<p class="calibre4">Pour
installer <em class="calibre5">mongoose</em>&nbsp;: <span class="code2">npm
install mongoose</span>.
Remarquez que <em class="calibre5">mongoose</em> requiert le module <em class="calibre5">mongodb</em>.</p>
<p class="calibre4">Voici le code source de notre exemple.</p>
<div class="code3">
varmongoose
=require('mongoose');<br class="calibre1"></br>
<br class="calibre1"></br>
// 1- Déclaration du modèle<br class="calibre1"></br>
varutilisateurSchema = mongoose.Schema({<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; nom: String,<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; nb:Number,<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; adresse: {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
voie:
String,<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ville:
String<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; }<br class="calibre1"></br>
});<br class="calibre1"></br>
utilisateurSchema.methods.hello =function() {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; console.log("Bonjour, je
m'appelle " +this.nom + "&nbsp;!");<br class="calibre1"></br>
};<br class="calibre1"></br>
var Utilisateur =mongoose.model('utilisateurs',
utilisateurSchema);<br class="calibre1"></br>
<br class="calibre1"></br>
// 2- Opérations sur les données<br class="calibre1"></br>
vardb = mongoose.connection;<br class="calibre1"></br>
db.once('open',function() {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; var pierre = new Utilisateur({<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;nom:
'Pierre',<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
adresse: {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
voie: 'Avenue des Rues',<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ville: 'Rennes'<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; });<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;pierre.save(function(err, utilisateur) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
utilisateur.hello();<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mongoose.disconnect();<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; });<br class="calibre1"></br>
});<br class="calibre1"></br>
mongoose.connect('mongodb://localhost/mabase2');
</div>
<p class="calibre4">J'ai séparé le code source en deux parties, la première
constituée de la déclaration du modèle, et la seconde d'exemples
d'opérations
possibles sur les données grâce à ce modèle.</p>
<h4 class="calibre14">4.2.2.1&nbsp;&nbsp;
Déclaration du modèle</h4>
<p class="calibre4">Tout d'abord nous déclarons un <em class="calibre5">schéma</em>, <span class="code2">utilisateurSchema</span>.
Un schéma permet de définir une structure au document que nous allons
utiliser,
une sorte de modèle (à ne pas confondre avec les modèles que nous
allons voir
par la suite). Pour notre schéma d'utilisateur, nous déclarons trois
attributs
:</p>
<ul class="calibre6">
  <li class="calibre7"><span class="code2">nom</span>, de type chaîne de caractère <em class="calibre5">(String)</em>&nbsp;;</li>
  <li class="calibre7"><span class="code2">nb</span>, de type nombre <em class="calibre5">(Number)</em>&nbsp;;</li>
  <li class="calibre7">et adresse, objet contenant un attribut voie et un
attribut ville.</li>
</ul>
<p class="calibre4">Nous déclarons ensuite dans ce schéma une <em class="calibre5">méthode</em>
appelée <span class="code2">hello</span>.
Nous pourrons alors appeler cette méthode sur n'importe quel objet
héritant de
notre schéma&nbsp;; nous y reviendrons.</p>
<p class="calibre4">À partir de ce schéma, nous créons un <em class="calibre5">modèle</em>
que nous
appelons <span class="code2">Utilisateur</span>,
que nous associons à la collection Mongo utilisateurs. Si vous êtes
habitués à la
programmation objet, ce modèle représente en quelque sorte une classe,
à partir
de laquelle nous allons pouvoir créer nos objets utilisateurs.</p>
<h4 class="calibre14">4.2.2.2&nbsp;&nbsp;
Opérations sur les
données</h4>
<p class="calibre4">Nous déclarons tout d'abord un objet <span class="code2">db</span>
qui
nous permet d'accéder à notre base Mongo&nbsp;: <span class="code2">var db
= mongoose.connection;</span>.</p>
<p class="calibre4">Puis, par la méthode <span class="code2">once</span> de notre
objet <span class="code2">db</span> nous
déclarons quoi faire lorsque nous sommes parvenus à nous connecter à la
base,
en passant comme paramètre une fonction appelée alors.</p>
<p class="calibre4">Dans cette fonction, nous commençons par créer un objet
utilisateur nomme <span class="code2">pierre</span>,
à partir du modèle <span class="code2">Utilisateur</span>.
Nous initialisons cet objet avec des données&nbsp;: son nom et son
adresse.
Notez que nous ne définissons par l'attribut <span class="code2">nb</span>
déclaré dans le schéma, rien ne nous
oblige à le faire tout de suite.</p>
<p class="calibre4">Enfin, nous enregistrons cet objet <span class="code2">pierre</span>,
autrement dit nous le créons
dans la base Mongo. La fonction donnée en paramètre à la méthode <span class="code2">save</span>
a deux paramètres, le premier étant l'erreur éventuelle, le second
l'objet
effectivement enregistré.</p>
<p class="calibre4">Une fois l'utilisateur enregistré, nous appelons sa méthode <span class="code2">hello</span>
(que nous
avions déclarée dans le schéma <span class="code2">utilisateurSchema</span>,
puis nous
fermons la connexion via <span class="code2">mongoose.disconnect()</span>.</p>
<p class="calibre4">Nous avons déclaré les actions à effectuer lorsque nous
étions connecté à la base&nbsp;; encore faut-il s'y connecter
effectivement&nbsp;:
avec <span class="code2">mongoose.connect('mongodb://localhost/mabase2')</span>,
nous nous connectons à
la base <span class="code2">mabase2</span>
sur le serveur local.</p>
<h4 class="calibre14">4.2.2.3&nbsp;&nbsp;
Exécution de l'exemple</h4>
<p class="calibre4">Pour exécuter l'exemple, il est nécessaire de lancer le
serveur MongoDB s'il est pas déjà en cours d'exécution.
Cela se fait à l'aide du programme <span class="code2">mongod</span>. Il
est possible que vous
deviez passer en paramètre de ce programme le chemin du répertoire de
stockage
des bases Mongo. Par exemple sous Windows&nbsp;: <span class="code2">mongod
&ndash;dbpath
C:\Temp\mongodb.</span></p>
<p class="calibre4">Une fois que notre serveur MongoDB tourne, nous pouvons
exécuter le script&nbsp;:</p>
<div class="code3">
$ node
mongoose01.js<br class="calibre1"></br>
Bonjour, je m'appelle Pierre&nbsp;!
</div>
<h3 id="calibre_link-46" class="calibre11">4.2.3&nbsp;&nbsp;&nbsp;
Conclusion sur MongoDB</h3>
<p class="calibre4">Nous avons donc vu les rudiments de MongoDB et de son
utilisation avec Node.js. Bien évidemment, MongoDB permet des
opérations bien
plus complexes que celles que nous venons de voir, je vous encourage à
feuilleter la documentation de MongoDB et du module <em class="calibre5">mongoose</em>.</p>

</div></div>

<div class="calibre" id="calibre_link-6">

<h1 id="calibre_link-47" class="calibre13">Chapitre
5 : Créez et
diffusez vos modules</h1>
<p class="calibre4">Nous l'avons vu, l'une des forces de Node.js est la
possibilité qu'il donne d'étendre ses fonctionnalités au moyen de
modules. Nous
avons vu des modules intégrés à la distribution par défaut de Node.js <em class="calibre5">(http,
url,fs)</em>, des modules tiers récupérés via le
gestionnaire de paquets <em class="calibre5">npm</em> <em class="calibre5">(express,
mongoose…)</em>, mais vous vous doutez bien qu'il est
possible de créer vos propres modules.</p>
<p class="calibre4">Il y a typiquement deux raisons qui peuvent vous pousser à
créer vos propres modules&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7">structurer une application qui devient complexe :
modulariser votre code le rend plus facile à maintenir ou à
débuguer&nbsp;;</li>
  <li class="calibre7">rendre des parties de votre code réutilisables au
sein d'un autre projet ou par la communauté.</li>
</ul>
<p class="calibre4">Pour ce chapitre, nous allons développer un module très
simple qui utilise l'API de <em class="calibre5">geocoding</em> de Google,
documentée à l'adresse
https://developers.google.com/maps/documentation/geocoding/?hl=fr.
Le principe de cette API est le suivant : on lui donne une adresse (par
exemple «&nbsp;Place de Bretagne, Rennes&nbsp;»), et elle nous
renvoie diverses
informations sur cette adresse, et notamment ses coordonnées (latitude
et
longitude).</p>
<h2 id="calibre_link-48" class="calibre12">5.1&nbsp;&nbsp;&nbsp;&nbsp;
Spécifications
de notre module</h2>
<p class="calibre4">Notre module, que j'ai choisi d'appeler sobrement <em class="calibre5">google-geocoding</em>,
disposera d'une seule
méthode&nbsp;: <span class="code2">geocode</span>. Celle-ci prendra
deux
paramètres&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7">l'adresse dont on souhaite avoir les coordonnées
;</li>
  <li class="calibre7">la fonction à appeler une fois l'appel effectué,
elle-même prenant deux paramètres&nbsp;:</li>
  <li class="calibre7">l'erreur
éventuelle en cas de problème d'appel à l'API (null
sinon)&nbsp;;</li>
  <li class="calibre7">le
résultat du geocoding sous forme d'objet <span class="code2">{ lat:
48.1091828,lng&nbsp;:
-1.6839106 }</span>, ou null si Google n'a pas trouvé
notre adresse.</li>
</ul>
<p class="calibre4">Voici un exemple d'utilisation de notre futur module&nbsp;:</p>
<div class="code3">
var google_geocoding
= require('./google-geocoding');<br class="calibre1"></br>
<br class="calibre1"></br>
google_geocoding.geocode('Place de Bretagne, Rennes',function(err,
location) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; if( err )
{<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console.log('Erreur&nbsp;: ' + err);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; } else
if(&nbsp;!location ) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console.log('Aucun résultat.');<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; } else {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;console.log('Latitude&nbsp;: ' +
location.lat
+ '&nbsp;; Longitude&nbsp;: ' + location.lng);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; }<br class="calibre1"></br>
});
</div>
<p class="calibre4">Si vous exécutez ce code, vous obtiendrez naturellement une
erreur&nbsp;: notre module n'existe pas encore. Notez que
l'instruction <span class="code2">require</span>
fait appel au module par <span class="code2">./google-geocoding</span>
car le module se situera dans le fichier <span class="code2">google-geocoding.js</span>
situé dans le même
répertoire.</p>
<p class="calibre4">Créons ce fichier avec le contenu suivant&nbsp;:</p>
<div class="code3">
module.exports.geocode = function(address, callback) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; callback('Not implemented', null);<br class="calibre1"></br>
};
</div>
<p class="calibre4">Il ne fait rien pour l'instant, mais cela va nous permettre
de l'utiliser sans avoir d'exception déclenchée par Node.</p>
<h2 id="calibre_link-49" class="calibre12">5.2&nbsp;&nbsp;&nbsp;&nbsp;
Testons
notre module avec Mocha</h2>
<p class="calibre4">Et là vous cherchez si vous n'avez pas oublié de lire un
chapitre. Et bien non&nbsp;: nous allons bien tester notre module <em class="calibre5">google-geocoding</em>
avant même de l'écrire. En réalité,
nous n'allons qu'écrire les tests unitaires, autrement dit nous allons
appliquer la méthode bien connue et très en vogue de développement des <em class="calibre5">TDD</em>,
pour <em class="calibre5">test-driven development</em>.
Le principe est simple&nbsp;: écrire les tests en fonction des
spécifications
et non du code testé. Idéalement, ces tests sont mêmes écrits par un
autre
développeur que celui écrivant le code testé.</p>
<p class="calibre4">Entrons dans le vif du sujet&nbsp;: <em class="calibre5">Mocha</em>.
Il s'agit
d'un module (qui s'installe avec <span class="code2">npm install -g mocha</span>)
permettant de réaliser très simplement
des tests unitaires sur du code JavaScript, et plus particulièrement
avec
Node.js. En complément de Mocha, nous utiliserons également le module <em class="calibre5">Should</em>
(<span class="code2">npm install should</span>)
facilitant l'écriture des tests unitaires.</p>
<p class="calibre4">Une fois le module Mocha installé, la commande <span class="code2">mocha</span>
peut être exécutée en ligne de commande afin de lancer les tests. Par
défaut,
Mocha va chercher les tests dans le fichier <em class="calibre5">tests/test.js</em>.
Créons donc
ce fichier, avec le contenu suivant&nbsp;:</p>
<div class="code3">
var should =
require('should');<br class="calibre1"></br>
vargoogle_geocoding =
require('../google-geocoding');<br class="calibre1"></br>
<br class="calibre1"></br>
describe('Google geocoding', function(){<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; describe('#geocode()', function(){<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; <br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
it('should
return null on incorrect address', function(done){<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
google_geocoding.geocode('tototititutu',
function(err, location) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
should.not.exist(err);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
should.not.exist(location);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
done();<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
it('should
return non null on correct address', function(done){<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
google_geocoding.geocode('Place de Bretagne, Rennes',
function(err, location) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
should.not.exist(err);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
location.should.have.property('lat');<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
location.should.have.property('lng');<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
done();<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; });<br class="calibre1"></br>
});
</div>
<p class="calibre4">Mocha permet d'écrire les tests avec une syntaxe très
intuitive
(tout en restant du vrai code JavaScript) au moyen de fonctions comme
describe
ouit.
Ces deux fonctions ne servent qu'à organiser les tests. Ici comme nous
n'avons
qu'une seule méthode à tester, l'organisation reste relativement simple.</p>
<p class="calibre4">Nous déclarons ici deux cas de test&nbsp;: un pour une
adresse incorrecte (auquel cas notre méthode <span class="code2">geocode</span>
ne renvoie pas d'erreur et un résultat null), et un
pour une adresse correcte.</p>
<p class="calibre4">Le module <em class="calibre5">should</em> nous permet d'écrire
des <em class="calibre5">assertions</em>,
comme «&nbsp;<span class="code2">location</span>
doit avoir une propriété<em class="calibre5">lat</em>&nbsp;». Cela
s'écrit&nbsp;: <span class="code2">location.should.have.property('lat');</span>.
Facile non&nbsp;?</p>
<p class="calibre4">Pour déclarer qu'un objet (ici <span class="code2">err</span>)
doit être nul, on utilisera <span class="code2">should.not.exist(err)</span>.
On ne peut
pas utiliser la syntaxe <span class="code2">err.should.not.exist</span>,
car par
définition si <span class="code2">err</span> est nul, alors il ne peut
pas
disposer de la propriété <span class="code2">should</span>.</p>
<p class="calibre4">À présent lançons nos tests&nbsp;! Dans le répertoire du
module, tapez la commande <span class="code2">mocha -R spec</span> et
observez le résultat&nbsp;: (l'option <span class="code2">-R spec</span>
ne
sert qu'à avoir un affichage plus détaillé.)</p>
<div class="code3">
$ mocha -R spec<br class="calibre1"></br>
<br class="calibre1"></br>
&nbsp; Google geocoding<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; #geocode()<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1) should return
null
on incorrect address<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2) should return non
null on correct address<br class="calibre1"></br>
<br class="calibre1"></br>
&nbsp; 0 passing (8ms)<br class="calibre1"></br>
&nbsp; 2 failing<br class="calibre1"></br>
(...)
</div>
<p class="calibre4">Sans surprise, les tests ne passent pas. Notez tout de même
que
l'affichage généré par Mocha rend le résultat facilement
compréhensible, avec
le détail et la trace de chaque erreur (que je n'ai pas reproduits ici).</p>
<p class="calibre4">Maintenant que notre module est testable, il est temps d'en
écrire le contenu.</p>
<h2 id="calibre_link-50" class="calibre12">5.3&nbsp;&nbsp;&nbsp;&nbsp;
Le
module de geocoding</h2>
<p class="calibre4">Voici le code de notre module, à placer dans notre fichier <em class="calibre5">google-geocoding.js</em>
:</p>
<div class="code3">
var http = require("http");<br class="calibre1"></br>
<br class="calibre1"></br>
module.exports.geocode = function(address, callback) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; <br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; varurl =
"http://maps.googleapis.com/maps/api/geocode/json?address="
+encodeURIComponent(address)
+ "&amp;sensor=false";<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; <br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;http.get(url, function(res) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if( res.statusCode&nbsp;!= 200 ) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
callback("Statut HTTP = " + res.statusCode, null);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} else {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var output = '';<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res.setEncoding('utf8');<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res.on('data', function (chunk) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
output += chunk;<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
});<br class="calibre1"></br>
<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res.on('end', function() {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var response =JSON.parse(output);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if(response.status == "OK" ) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var location =response.results[0].geometry.location;<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
callback(null, location);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} else if(response.status ==
"ZERO_RESULTS" ) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
callback(null, null);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} else {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
callback("Status = " +response.status,
null);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
});<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; }).on('error', function(e) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
callback(e.message, null);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; });<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; <br class="calibre1"></br>
};
</div>
<p class="calibre4">Rien de vraiment nouveau ici par
rapport à ce que nous avons vu. Notez l'utilisation de la méthode <span class="code2">get</span>
du module <em class="calibre5">http</em>, qui permet non pas de créer un
serveur mais de lancer
une requête HTTP <em class="calibre5">GET</em> sur un serveur, ici le
serveur de l'API Google. La
particularité ici est que l'on lit le retour de cet appel par morceaux <em class="calibre5">(chunks)</em>,grace
à <span class="code2">res.on('data',...)</span> et <span class="code2">res.on('end',...)</span>.</p>
<p class="calibre4">Pour déclarer une méthode <em class="calibre5">publique</em> du
module, on
utilise l'objet <span class="code2">module</span>,
et sa propriété <span class="code2">exports</span>.
Ainsi nous pourrions créer un module ainsi&nbsp;:</p>
<div class="code3">
var f =function()
{ ... };<br class="calibre1"></br>
var g =function() { ...
f(); ... }<br class="calibre1"></br>
module.exports = {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;super_methode:
function() { ... g(); ... }<br class="calibre1"></br>
};
</div>
<p class="calibre4">La fonction <span class="code2">g</span> utilise la fonction <span class="code2">f</span>,
et nous rendons une méthode publique,
<span class="code">super_methode</span> qui fait appel à <span class="code4">g</span>.
Mais si nous utilisons notre module, nous ne pourrons utiliser ni <span class="code4">f
</span>
ni <span class="code4">g</span>, car celles-ci
n'ont pas été exportées.<p class="calibre4"></p>
<p class="calibre4">À présent, si nous exécutons à nouveau notre petit script
d'exemple,
nous obtenons l'affichage suivant&nbsp;:</p>
<div class="code5">
$ node
app.js<br class="calibre1"></br>
Latitude&nbsp;: 48.1091828&nbsp;; Longitude&nbsp;:
-1.6839106
</div>
<p class="calibre4">Et si nous lançons notre test avec <em class="calibre5">mocha</em>&nbsp;:</p>
<div class="code5">
D:\Documents\nodejs\google_geocoding&gt;mocha -R spec<br class="calibre1"></br>
<br class="calibre1"></br>
&nbsp; Google geocoding<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; #geocode()<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V should return null
on
incorrect address (118ms)<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V should return non
null on correct address (119ms)<br class="calibre1"></br>
<br class="calibre1"></br>
&nbsp; 2 passing (251ms)
</div>
<p class="calibre4">Miracle, notre module vient de passer les tests unitaires
avec succès&nbsp;!</p>
<h2 id="calibre_link-51" class="calibre15">5.4&nbsp;&nbsp;&nbsp;&nbsp;
Diffusons
notre module</h2>
<p class="calibre4">Maintenant que nous sommes fiers de notre module, nous
pouvons le diffuser afin qu'il soit utilisable par d'autres personnes,
en
utilisant le gestionnaire de paquets <em class="calibre5">npm</em>.</p>
<p class="calibre4">Pour cela, il est nécessaire d'effectuer quelques
modifications. Tout d'abord, nous allons créer le fichier qui décrit
notre
module, le fichier package.json. Celui-ci contient
les informations de base (nom, auteur…), mais aussi les modules requis
par son
installation.</p>
<p class="calibre4">Voici un exemple de <em class="calibre5">package.json</em>
pour notre module&nbsp;:</p>
<div class="code5">
{<br class="calibre1"></br>
&nbsp; "author": "Votre
nom &lt;votre.email@example.com&gt;",<br class="calibre1"></br>
&nbsp; "name": "google-geocoding",<br class="calibre1"></br>
&nbsp; "description": "Small Node
module to use Google Geocoding API.",<br class="calibre1"></br>
&nbsp; "version": "0.1.1",<br class="calibre1"></br>
&nbsp; "repository": {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; "url":
""<br class="calibre1"></br>
&nbsp; },<br class="calibre1"></br>
&nbsp; "keywords": [<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; "google",<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; "geocoding",<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; "latitude",<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; "longitude",<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; "coordinates"<br class="calibre1"></br>
&nbsp; ],<br class="calibre1"></br>
&nbsp; "main": "",<br class="calibre1"></br>
&nbsp; "dependencies": {}, <br class="calibre1"></br>
&nbsp; "devDependencies":
{<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; "mocha": "*"<br class="calibre1"></br>
&nbsp; },<br class="calibre1"></br>
&nbsp; "optionalDependencies":
{},<br class="calibre1"></br>
&nbsp; "engines": {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; "node": "*"<br class="calibre1"></br>
&nbsp; },<br class="calibre1"></br>
&nbsp; "scripts": {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; "test": "mocha -R
spec"<br class="calibre1"></br>
&nbsp; }<br class="calibre1"></br>
}
</div>
<p class="calibre4">De nombreuses options sont disponibles pour ce
fichier&nbsp;; je vous encourage à aller faire un tour du côté de
la documentation
(https://npmjs.org/doc/json.html)
pour voir toutes les possibilités.</p>
<p class="calibre4">Nous avons également besoin d'un fichier <em class="calibre5">README</em>&nbsp;;
même si cela n'est pas forcément requis, cela est fortement conseillé
pour les
utilisateurs qui souhaiteraient utiliser notre module. Il décrit
typiquement au
moins la procédure d'installation, et un exemple d'utilisation.</p>
<div class="code5">
google-geocoding<br class="calibre1"></br>
=====================<br class="calibre1"></br>
<br class="calibre1"></br>
This module allows you to
use [Google geocoding
API](https://developers.google.com/maps/documentation/geocoding/) to
get the
coordinates of a specific location.<br class="calibre1"></br>
<br class="calibre1"></br>
Installation<br class="calibre1"></br>
------------<br class="calibre1"></br>
<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;npm
install google-geocoding<br class="calibre1"></br>
<br class="calibre1"></br>
Example<br class="calibre1"></br>
-------<br class="calibre1"></br>
<br class="calibre1"></br>
```javascript<br class="calibre1"></br>
vargoogle_geocoding =
require('google-geocoding');<br class="calibre1"></br>
<br class="calibre1"></br>
google_geocoding.geocode('Place de Bretagne, Rennes, France',
function(err,
location) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; if( err ) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console.log('Error: ' + err);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; } else if(&nbsp;!location ) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console.log('No result.');<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; } else {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console.log('Latitude: ' +location.lat + '&nbsp;;
Longitude: ' +location.lng);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; }<br class="calibre1"></br>
});<br class="calibre1"></br>
```
</div>
<p class="calibre4">Le plus simple pour le <em class="calibre5">README</em> est
d'utiliser le
format Markdown (http://fr.wikipedia.org/wiki/Markdown),
très en vogue actuellement et
s'affichant très bien sur <em class="calibre5">npmjs.org</em> où notre
module sera disponible.
Appelons donc le fichier <em class="calibre5">README.md</em>.</p>
<p class="calibre4">Par ailleurs, modifions le fichier de test <em class="calibre5">test/test.js</em>
afin que le la ligne require de notre module
devienne&nbsp;:</p>
<div class="code5">
var google_geocoding = require('google-geocoding');
</div>
<p class="calibre4">Je reviendrais un peu plus bas sur l'intérêt de cette
modification.</p>
<p class="calibre4">La dernière manipulation à effectuer consiste à nettoyer un
peu le contenu du répertoire du module. Commencez par supprimer (ou
déplacer
ailleurs) les fichiers autres que <em class="calibre5">google-geocoding.js</em>
et <em class="calibre5">test/test.js</em>
(et évidemment les fichiers <em class="calibre5">README.md</em> et <em class="calibre5">package.json</em>
que nous venons de créer). Puis renommez le fichier <em class="calibre5">google-geocoding.js</em>
en <em class="calibre5">index.js</em> ; ainsi il sera considéré comme le
fichier <em class="calibre5">par défaut</em>
du module, c'est lui qui sera appelé lorsque l'on écrira <span class="code4">require('google-geocoding')</span>.</p>
<p class="calibre4">Nous obtenons donc l'arborescence suivante&nbsp;:</p>
<ul class="calibre6">
  <li class="calibre7">test
    <ul class="calibre10">
      <li class="calibre7">test.js</li>
    </ul>
  </li>
  <li class="calibre7">README.md</li>
  <li class="calibre7">package.json</li>
  <li class="calibre7">index.js</li>
</ul>
<p class="calibre4">Notre module est maintenant prêt à être diffusé. Tout
d'abord, il est nécessaire de se créer un compte sur les dépôts de <em class="calibre5">npm</em>.
Cela se fait à l'adresse http://npmjs.org/.</p>
<p class="calibre4">Deux commandes suffisent ensuite à rendre notre module
public&nbsp;:</p>
<div class="code5">
$ npm adduser<br class="calibre1"></br>
Username: &lt;saisir votre login npmjs.org&gt;<br class="calibre1"></br>
Password: &lt;saisir votre mot de passe&gt;<br class="calibre1"></br>
Email: &lt;saisir votre e-mail&gt;<br class="calibre1"></br>
npm http PUT
https://registry.npmjs.org/-/user/org.couchdb.user:votrelogin<br class="calibre1"></br>
npm http 201
https://registry.npmjs.org/-/user/org.couchdb.user:votrelogin<br class="calibre1"></br>
<br class="calibre1"></br>
$ npm publish<br class="calibre1"></br>
npm http PUT https://registry.npmjs.org/google-geocoding<br class="calibre1"></br>
npm http 201 https://registry.npmjs.org/google-geocoding<br class="calibre1"></br>
npm http GET https://registry.npmjs.org/google-geocoding<br class="calibre1"></br>
npm http 200 https://registry.npmjs.org/google-geocoding<br class="calibre1"></br>
npm http PUT
https://registry.npmjs.org/google-geocoding/-/google-geocoding-0.1.1.tgz/-rev/1-08931f6eef42fb88dc95f6dfc8f30b81<br class="calibre1"></br>
npm http 201
https://registry.npmjs.org/google-geocoding/-/google-geocoding-0.1.1.tgz/-rev/1-08931f6eef42fb88dc95f6dfc8f30b81<br class="calibre1"></br>
npm http PUT
https://registry.npmjs.org/google-geocoding/0.1.1/-tag/latest<br class="calibre1"></br>
npm http 201
https://registry.npmjs.org/google-geocoding/0.1.1/-tag/latest<br class="calibre1"></br>
+ google-geocoding@0.1.1
</div>
<p class="calibre4">Et voilà, le module est diffusé. Vous pourrez constater sa
présence en vous rendant sur la page de votre compte sur http://npmjs.org
(quelques minutes sont parfois nécessaires pour le voir apparaître).</p>
<p class="calibre4">Pour tester l'installation, il nous suffit de reprendre le
script d'exemple vu précédemment, en pensant à utiliser <span class="code4">require('google-geocoding')</span>
et non <span class="code4">require('./google-geocoding')</span>
:</p>
<div class="code5">
vargoogle_geocoding
=require('google-geocoding');<br class="calibre1"></br>
<br class="calibre1"></br>
google_geocoding.geocode('Place de Bretagne, Rennes',function(err,
location) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; if(err )
{<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console.log('Erreur&nbsp;: ' +err);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; } else
if(&nbsp;!location ) {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console.log('Aucun résultat.');<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; } else {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console.log('Latitude&nbsp;: ' +location.lat +
'&nbsp;; Longitude&nbsp;: ' +location.lng);<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; }<br class="calibre1"></br>
});
</div>
<p class="calibre4">Penser à installer le module <em class="calibre5">google-geocoding</em>
avant de lancer le programme&nbsp;:</p>
<div class="code5">
$ npm install google-geocoding<br class="calibre1"></br>
npm http GET https://registry.npmjs.org/google-geocoding<br class="calibre1"></br>
npm http 200 https://registry.npmjs.org/google-geocoding<br class="calibre1"></br>
google-geocoding@0.1.1node_modules\google-geocoding<br class="calibre1"></br>
<br class="calibre1"></br>
$ node test-geocoding.js<br class="calibre1"></br>
Latitude&nbsp;: 48.1091828&nbsp;; Longitude&nbsp;:
-1.6839106
</div>
<p class="calibre4">Il nous reste une dernière chose à tester. Nous avions créé
un petit script permettant de tester unitairement notre module. Et bien
<em class="calibre5">npm</em> peut lancer les tests pour nous. En effet nous
avons indiqué dans le <em class="calibre5">package.json</em> :</p>
<div class="code5">
"scripts": {<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; "test": "mocha -R
spec"<br class="calibre1"></br>
}
</div>
<p class="calibre4">Cette option indique à<em class="calibre5">npm</em>
qu'il peut lancer les tests en exécutant la commande <span class="code4">mocha</span>.
À
présent, si nous lançons la commande <span class="code4">npm test
google-geocoding</span>,
<em class="calibre5">npm</em> va exécuter la commande <span class="code4">mocha</span>
sur notre module fraîchement installé.</p>
<div class="code5">
$ npm test google-geocoding<br class="calibre1"></br>
<br class="calibre1"></br>
&gt; google-geocoding@0.1.1 test
D:\Documents\nodejs\node_modules\google-geocoding<br class="calibre1"></br>
&gt; mocha -R spec<br class="calibre1"></br>
<br class="calibre1"></br>
&nbsp; Google geocoding<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp; #geocode()<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V should return null
on
incorrect address (188ms)<br class="calibre1"></br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V should return non
null on correct address (133ms)<br class="calibre1"></br>
<br class="calibre1"></br>
&nbsp; 2 passing (332ms)
</div>
<h2 id="calibre_link-52" class="calibre15">5.5&nbsp;&nbsp;&nbsp;&nbsp;
Conclusion
sur les modules</h2>
<p class="calibre4">Les modules sont incontestablement l'une des plus grandes
forces de NodeJS. De la même manière que le monde du
logiciel libre, Node a progressé grâce à tout l'écosystème qui lui
gravite
autour, grâce à la simplicité pour créer des modules supplémentaires et
les
diffuser.</p>
<p class="calibre4">Avant de vous lancer dans le développement d'un nouveau
module, cherchez s'il n'en existe pas déjà un qui accomplit ce que vous
souhaitez. Peut-être en trouverez-vous un qui s'en approche, et s'il
est sous
licence libre, il pourra être très intéressant et très formateur de le
faire
évoluer à votre convenance. <em class="calibre5">npmjs.org</em> et <em class="calibre5">GitHub</em>
(http://github.com)
sont parfaitement adaptés pour ça&nbsp;!</p>

</div></div></div>

<div class="calibre" id="calibre_link-1">
<h1 id="calibre_link-53" class="calibre16">
Aller
plus loin</h1>
<p class="calibre4">JavaScript est un langage en pleine expansion, comme il l'a
été aux débuts du Web, ainsi que lors de l'apparition du Web 2.0 avec
les
technologies AJAX. Aujourd'hui cette expansion est d'autant plus
intéressante
qu'elle ne se limite plus à la dynamisation des sites et applications
web.</p>
<p class="calibre4">Grâce à Node.js, il devient un langage de plus en plus
polyvalent qui permet désormais de créer des applications serveur ou
des programmes
autonomes, voire même des applications mobiles grâce à l'envolée du
HTML5.</p>
<p class="calibre4">Node.js n'est pas le seul acteur de ce succès. AngularJS par
exemple devient de plus en plus répandu pour
la création d'interfaces clientes riches, en intégrant une logique
modèle-vue-contrôleur
côté client. Imaginez ce que peut donner une application web dont la
partie
cliente est basée surAngularJS et la partie serveur
sur Node.js avec Express&nbsp;!</p>
<p class="calibre4">Mais JavaScript reste un langage dont la syntaxe peut donner
des programmes difficilement compréhensibles et maintenables (des
tableaux de
fonctions renvoyant des fonctions qui renvoient des objets...). Il
existe des
langages destinés à faciliter la compréhension du code.</p>
<p class="calibre4"><em class="calibre5">CoffeeScript</em> (http://coffeescript.org)
est certainement le plus populaire
actuellement. A partir d'un code dont la syntaxe s'inspire du Python et
du
Ruby, c'est du JavaScript qui est généré après une phase de compilation.</p>
<p class="calibre4">Prenons par exemple le code suivant disponible dans la
documentation officielle de CoffeeScript : http://coffeescript.org/#conditionals&nbsp;:</p>
<div class="code5">
mood = greatlyImproved if singing<br class="calibre1"></br>
<br class="calibre1"></br>
if happy and knowsIt<br class="calibre1"></br>
&nbsp;clapsHands()<br class="calibre1"></br>
&nbsp;chaChaCha()<br class="calibre1"></br>
else<br class="calibre1"></br>
&nbsp;showIt()<br class="calibre1"></br>
<br class="calibre1"></br>
date = if friday then sue
else jill
</div>
<p class="calibre4">Après compilation, voici le JavaScript généré&nbsp;:</p>
<div class="code5">
var date, mood;<br class="calibre1"></br>
<br class="calibre1"></br>
if (singing) {<br class="calibre1"></br>
&nbsp;&nbsp;mood = greatlyImproved;<br class="calibre1"></br>
}<br class="calibre1"></br>
<br class="calibre1"></br>
if (happy &amp;&amp; knowsIt)
{<br class="calibre1"></br>
&nbsp;clapsHands();<br class="calibre1"></br>
&nbsp;chaChaCha();<br class="calibre1"></br>
} else {<br class="calibre1"></br>
&nbsp;showIt();<br class="calibre1"></br>
}<br class="calibre1"></br>
<br class="calibre1"></br>
date = friday&nbsp;? sue&nbsp;: jill;
</div>
<p class="calibre4">C'est lorsque l'on commence à utiliser des classes et des
objets queCoffeeScript révèle tout son potentiel. En
effet la programmation objet n'existe pas en JavaScript, bien que des
techniques permettent de faire tout comme, mais au prix d'un code
encore plus
difficilement compréhensible. CoffeeScript peut alorsrendre les choses
beaucoup
plus faciles&nbsp;!</p>
<p class="calibre4">C'est ainsi que s'achève notre exploration de Node.js.
J'espère que vous aurez pris
autant de plaisir à lire ce livre que j'en ai eu à l'écrire. J'espère
aussi vous avoir donné
envie d'en savoir plus sur Node.js et JavaScript en général. Nul doute
que JavaScript a encore
de beaux jours devant lui !
</p>


</div></div></div>

</body></html>
